---
phase: 04-signal-pipeline
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/risk_manager.py
  - app/config.py
autonomous: true

must_haves:
  truths:
    - "Per-trade risk is capped at 1% of account balance"
    - "Maximum concurrent active signals is enforced at 2"
    - "Daily loss limit of 2% suppresses signal generation after threshold"
    - "Position sizing is volatility-adjusted using ATR with 0.5x floor and 1.5x cap"
    - "Running and maximum drawdown are tracked"
  artifacts:
    - path: "app/services/risk_manager.py"
      provides: "RiskManager service with position sizing, concurrent limits, daily loss, drawdown"
      exports: ["RiskManager", "RiskCheckResult"]
      min_lines: 120
    - path: "app/config.py"
      provides: "account_balance setting"
      contains: "account_balance"
  key_links:
    - from: "app/services/risk_manager.py"
      to: "app/models/signal.py"
      via: "query active signal count for concurrent limit"
      pattern: "select.*Signal.*status.*active"
    - from: "app/services/risk_manager.py"
      to: "app/models/outcome.py"
      via: "query today's outcomes for daily loss calculation"
      pattern: "select.*Outcome.*pnl_pips"
    - from: "app/services/risk_manager.py"
      to: "app/config.py"
      via: "get_settings().account_balance for risk calculations"
      pattern: "get_settings.*account_balance"
---

<objective>
Build the RiskManager service that enforces per-trade risk limits (1% of account), maximum concurrent signals (2), daily loss limits (2% drawdown suppression), and volatility-adjusted position sizing. Also add account_balance to Settings.

Purpose: Capital protection is critical for prop firm trading. This service is the safety net that prevents the system from overexposing or trading after a losing streak.
Output: `app/services/risk_manager.py` with RiskManager class, `app/config.py` updated with account_balance field.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signal-pipeline/04-RESEARCH.md

@app/models/signal.py
@app/models/outcome.py
@app/config.py
@app/strategies/helpers/indicators.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add account_balance to Settings</name>
  <files>app/config.py</files>
  <action>
Add `account_balance: float = 100000.0` to the Settings class in app/config.py.

Place it in a new "# Trading" section below the existing "# Scheduling" section. Default to 100000.0 (standard prop firm demo account balance). This is sourced from the ACCOUNT_BALANCE environment variable.

Also add a comment: `# Prop firm account balance in USD (sourced from ACCOUNT_BALANCE env var)`
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.config import Settings; s = Settings(_env_file=''); print(f'account_balance={s.account_balance}')"` -- should print "account_balance=100000.0" (note: may need to handle missing env vars; the key test is that the field exists with default value)
  </verify>
  <done>
Settings.account_balance exists with default 100000.0, sourced from ACCOUNT_BALANCE env var.
  </done>
</task>

<task type="auto">
  <name>Task 2: RiskManager service with position sizing, limits, and drawdown</name>
  <files>app/services/risk_manager.py</files>
  <action>
Create `app/services/risk_manager.py` with these components:

**Configuration constants:**
- RISK_PER_TRADE: float = 0.01 (1% of account per trade)
- MAX_CONCURRENT_SIGNALS: int = 2
- DAILY_LOSS_LIMIT_PCT: float = 0.02 (2% daily drawdown limit)
- PIP_VALUE: float = 0.10 (XAUUSD: $0.10 price movement per pip)
- ATR_FACTOR_FLOOR: float = 0.5 (minimum position size multiplier)
- ATR_FACTOR_CAP: float = 1.5 (maximum position size multiplier)

**RiskCheckResult dataclass/pydantic model:**
- approved: bool
- rejection_reason: str | None
- position_size: Decimal | None (only set if approved)
- risk_amount: float | None
- daily_pnl: float | None

**RiskManager class:**

1. `async def check(self, session: AsyncSession, candidates: list[CandidateSignal]) -> list[tuple[CandidateSignal, RiskCheckResult]]`
   - For each candidate, run all risk checks IN ORDER:
     a. Check daily loss limit first (RISK-04) -- if breached, reject ALL remaining candidates
     b. Check concurrent signal limit (RISK-02)
     c. Calculate position size (RISK-01, RISK-03, RISK-06)
   - Return list of (candidate, RiskCheckResult) tuples
   - If daily loss limit is breached, log WARNING: "Daily loss limit breached ({pnl}), suppressing all signal generation"

2. `async def _check_daily_loss(self, session: AsyncSession) -> tuple[bool, float]`
   - Query Outcome table: SUM(pnl_pips) for signals WHERE signal.created_at >= today midnight UTC
   - Use `datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)` for day boundary
   - Compute daily loss as percentage: (daily_pnl_amount / account_balance)
   - Return (is_breached: bool, daily_pnl: float)
   - is_breached = True if daily_loss_pct <= -DAILY_LOSS_LIMIT_PCT (negative means loss)
   - If no outcomes exist today, return (False, 0.0)
   - Use get_settings().account_balance for the account balance

3. `async def _check_concurrent_limit(self, session: AsyncSession) -> tuple[bool, int]`
   - Query Signal table: COUNT(*) WHERE status="active"
   - Return (is_at_limit: bool, active_count: int)
   - is_at_limit = True if active_count >= MAX_CONCURRENT_SIGNALS

4. `def calculate_position_size(self, sl_distance_price: float, current_atr: float, baseline_atr: float) -> Decimal`
   - account_balance from get_settings().account_balance
   - risk_amount = account_balance * RISK_PER_TRADE
   - ATR factor = baseline_atr / current_atr, clamped to [ATR_FACTOR_FLOOR, ATR_FACTOR_CAP]
   - raw_size = (risk_amount / sl_distance_price) * atr_factor
   - Return Decimal(str(round(raw_size, 2)))
   - Handle edge cases: if sl_distance <= 0 or current_atr <= 0 or baseline_atr <= 0, return Decimal("0.01")

5. `async def get_drawdown_metrics(self, session: AsyncSession) -> dict`
   - Query all Outcomes ordered by created_at ASC
   - Compute running P&L (cumulative sum of pnl_pips)
   - Track running drawdown (peak - current) and maximum drawdown (worst peak-to-trough)
   - Return {"running_drawdown": float, "max_drawdown": float, "running_pnl": float, "peak_pnl": float}
   - If no outcomes, return all zeros

**Important implementation notes:**
- Daily P&L derived from DB each time (not a persistent counter) to avoid stale state across days -- this is the RESEARCH.md recommended approach to avoid Pitfall 5
- The check() method accepts already-validated candidates (validation is done by SignalGenerator)
- Position sizing uses the SL distance from the CandidateSignal: abs(float(candidate.entry_price) - float(candidate.stop_loss))
- For ATR values in position sizing, the caller (SignalPipeline) will provide current_atr and baseline_atr
- Float math internally, Decimal only at the position_size return boundary
- Comprehensive loguru logging
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -c "
from app.services.risk_manager import RiskManager, RiskCheckResult, RISK_PER_TRADE, MAX_CONCURRENT_SIGNALS, DAILY_LOSS_LIMIT_PCT
rm = RiskManager()
print(f'RISK_PER_TRADE={RISK_PER_TRADE}')
print(f'MAX_CONCURRENT={MAX_CONCURRENT_SIGNALS}')
print(f'DAILY_LOSS_LIMIT={DAILY_LOSS_LIMIT_PCT}')
# Test position sizing with mock values
size = rm.calculate_position_size(sl_distance_price=3.50, current_atr=5.0, baseline_atr=4.0)
print(f'Position size: {size}')
"` -- should print config values and a calculated position size
  </verify>
  <done>
RiskManager service exists with: check() enforcing 2% daily loss limit + 2 concurrent signal max, calculate_position_size() with ATR-scaled volatility adjustment (0.5x-1.5x), get_drawdown_metrics() for running/max drawdown. Settings.account_balance added with 100K default.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app.services.risk_manager import RiskManager, RiskCheckResult"` imports cleanly
- `python -c "from app.config import get_settings; print(get_settings().account_balance)"` returns 100000.0
- RISK_PER_TRADE is 0.01, MAX_CONCURRENT_SIGNALS is 2, DAILY_LOSS_LIMIT_PCT is 0.02
- calculate_position_size returns Decimal with 2 decimal places
- Position sizing handles edge cases (zero SL distance, zero ATR)
</verification>

<success_criteria>
- RiskManager is importable and instantiable
- Per-trade risk is 1% of account_balance (RISK-01)
- Max concurrent signals is 2 (RISK-02)
- Daily loss limit is 2% (RISK-04)
- Position sizing is ATR-adjusted with 0.5x floor, 1.5x cap (RISK-06)
- Drawdown metrics (running + max) are computable (RISK-05)
- Settings.account_balance defaults to 100000.0
</success_criteria>

<output>
After completion, create `.planning/phases/04-signal-pipeline/04-03-SUMMARY.md`
</output>
