---
phase: 04-signal-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/strategy_selector.py
autonomous: true

must_haves:
  truths:
    - "Strategy selector ranks all registered strategies by weighted composite score using backtest metrics"
    - "Strategies with fewer than 50 trades in the scoring window are excluded from selection"
    - "Current volatility regime (LOW/MEDIUM/HIGH) modifies strategy scores by +/-10%"
    - "Degraded strategies (win rate drop >15% or profit factor <1.0) are flagged and deprioritized"
  artifacts:
    - path: "app/services/strategy_selector.py"
      provides: "StrategySelector service with composite scoring, volatility regime, degradation detection"
      exports: ["StrategySelector", "VolatilityRegime", "StrategyScore"]
      min_lines: 150
  key_links:
    - from: "app/services/strategy_selector.py"
      to: "app/models/backtest_result.py"
      via: "async query for latest non-walk-forward BacktestResult per strategy"
      pattern: "select.*BacktestResult"
    - from: "app/services/strategy_selector.py"
      to: "app/models/candle.py"
      via: "async query for H1 candles to compute ATR for regime detection"
      pattern: "select.*Candle"
    - from: "app/services/strategy_selector.py"
      to: "app/strategies/helpers/indicators.py"
      via: "compute_atr for volatility regime classification"
      pattern: "compute_atr"
---

<objective>
Build the StrategySelector service that ranks strategies using weighted composite scoring of backtest metrics, classifies the current volatility regime via ATR percentile, applies regime-based score modifiers, detects strategy degradation, and selects the best strategy for signal generation.

Purpose: This is the brain that decides WHICH strategy generates the next signal. Without it, the system cannot dynamically adapt to market conditions or avoid degraded strategies.
Output: `app/services/strategy_selector.py` with StrategySelector class, VolatilityRegime enum, StrategyScore dataclass, and composite scoring logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signal-pipeline/04-RESEARCH.md

@app/models/backtest_result.py
@app/models/candle.py
@app/models/strategy.py
@app/strategies/base.py
@app/strategies/helpers/indicators.py
@app/strategies/helpers/session_filter.py
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: StrategySelector service with composite scoring and volatility regime</name>
  <files>app/services/strategy_selector.py</files>
  <action>
Create `app/services/strategy_selector.py` with these components:

**VolatilityRegime enum** (str, Enum): LOW, MEDIUM, HIGH

**StrategyScore dataclass/pydantic model:**
- strategy_name: str
- strategy_id: int
- composite_score: float
- win_rate: float
- profit_factor: float
- sharpe_ratio: float
- expectancy: float
- max_drawdown: float
- total_trades: int
- regime: VolatilityRegime
- is_degraded: bool
- degradation_reason: str | None

**METRIC_WEIGHTS dict:**
- win_rate: 0.30 (primary -- consistency)
- profit_factor: 0.25 (close second -- profitability)
- sharpe_ratio: 0.15
- expectancy: 0.15
- max_drawdown: 0.15 (inverted -- lower is better)

**StrategySelector class with these async methods:**

1. `select_best(session: AsyncSession) -> StrategyScore | None`
   - Queries the MOST RECENT non-walk-forward BacktestResult per strategy (filter: is_walk_forward != True, window_days=60 preferred, fallback to 30)
   - Excludes strategies with total_trades < 50 (SEL-07). Log warning for excluded strategies.
   - Calls `_compute_scores()` to rank remaining strategies
   - Calls `_detect_volatility_regime()` to get current regime
   - Applies regime modifier to scores (+10% / -10% based on strategy-regime suitability)
   - Checks degradation for each strategy
   - Returns highest-scoring StrategyScore, or None if no strategies qualify

2. `_compute_scores(results: list[BacktestResult]) -> list[StrategyScore]`
   - Normalize each metric to [0, 1] across all strategies in the results list
   - For single strategy, normalize to 0.5 (avoid division by zero)
   - max_drawdown is inverted: (1 - normalized_value)
   - Compute weighted sum using METRIC_WEIGHTS
   - Return list of StrategyScore sorted descending by composite_score

3. `_detect_volatility_regime(session: AsyncSession) -> VolatilityRegime`
   - Query latest 720 H1 candles (30 days) for XAUUSD
   - Compute ATR(14) via compute_atr() from helpers/indicators.py
   - Use percentile method: current ATR vs 30-day ATR series
   - Thresholds: <=25th percentile = LOW, >=75th = HIGH, else MEDIUM
   - If insufficient data, default to MEDIUM

4. `_apply_regime_modifier(scores: list[StrategyScore], regime: VolatilityRegime) -> list[StrategyScore]`
   - HIGH volatility: breakout_expansion gets -10%, others unchanged
   - LOW volatility: trend_continuation gets -10%, others unchanged
   - MEDIUM: no modification
   - Modifier is multiplicative: score * 1.10 or score * 0.90

5. `_check_degradation(strategy_name: str, current_result: BacktestResult, session: AsyncSession) -> tuple[bool, str | None]`
   - Query the OLDEST non-walk-forward BacktestResult for same strategy (baseline)
   - Compare current win_rate vs baseline win_rate: drop > 0.15 (absolute) = degraded
   - Check current profit_factor < 1.0 = degraded
   - Return (is_degraded, reason_string_or_none)
   - If no baseline exists (only one result), return (False, None)

**Important implementation notes:**
- All DB queries use async session (AsyncSession from sqlalchemy.ext.asyncio)
- Use `from app.strategies.helpers.indicators import compute_atr` for ATR computation
- Use `from app.strategies.base import candles_to_dataframe` if needed for DataFrame conversion
- Float math internally, no Decimal conversions needed in this service (scoring is internal)
- Import Strategy model as StrategyModel to avoid name conflict with BaseStrategy
- Comprehensive loguru logging at each step (strategy excluded, regime detected, scores computed, degradation found)
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.services.strategy_selector import StrategySelector, VolatilityRegime, StrategyScore; print('Import OK')"` -- should print "Import OK" with no errors.

Additionally verify the module has all expected exports:
`python -c "from app.services.strategy_selector import StrategySelector, VolatilityRegime, StrategyScore, METRIC_WEIGHTS; s = StrategySelector(); print(f'Weights sum: {sum(METRIC_WEIGHTS.values())}')"` -- should print "Weights sum: 1.0"
  </verify>
  <done>
StrategySelector service exists with: composite scoring using 5 weighted metrics, ATR-based volatility regime detection (LOW/MEDIUM/HIGH), regime-strategy score modifiers (+/-10%), degradation detection (win rate drop >15%, profit factor <1.0), minimum 50-trade enforcement, and select_best() returning the highest-scoring StrategyScore or None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-timeframe confluence check</name>
  <files>app/services/strategy_selector.py</files>
  <action>
Add a confluence check method to StrategySelector:

**`check_h4_confluence(session: AsyncSession, direction: str) -> bool`**
- Query latest 200 H4 XAUUSD candles
- Compute EMA-50 and EMA-200 using compute_ema() from helpers/indicators.py
- If direction is "BUY": return True if EMA-50 > EMA-200 (bullish trend)
- If direction is "SELL": return True if EMA-50 < EMA-200 (bearish trend)
- If insufficient data, return False (no boost)
- This method is called by SignalGenerator (Plan 02) AFTER generating a candidate, to decide whether to add +5 confidence boost

This is a public method because it will be called by the signal generator in Plan 02, not by the selector itself. The selector only chooses WHICH strategy to run; the confluence check enriches the confidence of the signal produced.

Also add to the module docstring a note explaining that check_h4_confluence is intended to be called by SignalGenerator for SEL-04 multi-timeframe confluence scoring.
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.services.strategy_selector import StrategySelector; s = StrategySelector(); print(hasattr(s, 'check_h4_confluence'))"` -- should print "True"
  </verify>
  <done>
StrategySelector has check_h4_confluence(session, direction) method that queries H4 candles, computes EMA-50 vs EMA-200, and returns True if higher timeframe agrees with signal direction. Returns False on insufficient data.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app.services.strategy_selector import StrategySelector, VolatilityRegime, StrategyScore, METRIC_WEIGHTS"` imports cleanly
- METRIC_WEIGHTS values sum to 1.0
- StrategySelector has methods: select_best, check_h4_confluence
- VolatilityRegime has values: LOW, MEDIUM, HIGH
- StrategyScore has fields: strategy_name, strategy_id, composite_score, is_degraded, degradation_reason
</verification>

<success_criteria>
- StrategySelector service is importable and instantiable
- Composite scoring implements all 5 weighted metrics with correct weights
- Volatility regime detection uses ATR percentile with 25th/75th thresholds
- Strategies with <50 trades are excluded
- Degradation detection flags win rate drops >15% and profit factor <1.0
- Multi-timeframe confluence check (EMA-50 vs EMA-200 on H4) is available
</success_criteria>

<output>
After completion, create `.planning/phases/04-signal-pipeline/04-01-SUMMARY.md`
</output>
