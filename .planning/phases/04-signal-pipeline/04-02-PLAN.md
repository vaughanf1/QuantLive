---
phase: 04-signal-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/signal_generator.py
autonomous: true

must_haves:
  truths:
    - "Generated signals include all required fields: direction, entry, SL, TP1, TP2, R:R, confidence, strategy name, reasoning"
    - "Signals with R:R below 1:2 are automatically rejected"
    - "Signals with confidence below 65% are automatically rejected"
    - "Duplicate signals for the same direction within 4 hours are suppressed"
    - "Each signal has an expiry timestamp (8h for H1, 24h for H4)"
    - "System detects directional bias when signal distribution is systematically skewed"
  artifacts:
    - path: "app/services/signal_generator.py"
      provides: "SignalGenerator service with generation, validation, dedup, expiry, bias detection"
      exports: ["SignalGenerator"]
      min_lines: 150
  key_links:
    - from: "app/services/signal_generator.py"
      to: "app/strategies/base.py"
      via: "BaseStrategy.get_strategy() to instantiate and run analyze()"
      pattern: "BaseStrategy\\.get_strategy|strategy\\.analyze"
    - from: "app/services/signal_generator.py"
      to: "app/models/signal.py"
      via: "query Signal table for dedup check and signal count"
      pattern: "select.*Signal"
    - from: "app/services/signal_generator.py"
      to: "app/models/candle.py"
      via: "query candles for strategy analysis"
      pattern: "select.*Candle"
---

<objective>
Build the SignalGenerator service that runs a selected strategy's analyze() method on latest candle data, validates candidate signals against R:R and confidence thresholds, deduplicates against recent active signals, assigns expiry timestamps, and detects directional bias.

Purpose: This is the core signal creation engine that transforms strategy analysis into validated, de-duplicated trade signals ready for risk management checks.
Output: `app/services/signal_generator.py` with SignalGenerator class containing generate(), validate(), and bias detection logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signal-pipeline/04-RESEARCH.md

@app/strategies/base.py
@app/models/signal.py
@app/models/candle.py
@app/models/strategy.py
@app/strategies/helpers/session_filter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SignalGenerator service with generation and validation</name>
  <files>app/services/signal_generator.py</files>
  <action>
Create `app/services/signal_generator.py` with these components:

**Configuration constants at module level:**
- MIN_RR: float = 2.0 (minimum risk:reward ratio -- 1:2)
- MIN_CONFIDENCE: float = 65.0 (minimum confidence threshold)
- DEDUP_WINDOW_HOURS: int = 4 (same-direction dedup window)
- EXPIRY_HOURS: dict = {"M15": 4, "H1": 8, "H4": 24, "D1": 48}
- BIAS_WINDOW_SIGNALS: int = 20 (number of recent signals to check for bias)
- BIAS_SKEW_THRESHOLD: float = 0.75 (if >75% of recent signals are same direction, flag bias)

**SignalGenerator class:**

1. `async def generate(self, session: AsyncSession, strategy_name: str) -> list[CandidateSignal]`
   - Import BaseStrategy and concrete strategies inside method body to trigger registration (follow Phase 3 pattern to avoid circular imports)
   - Get strategy instance via BaseStrategy.get_strategy(strategy_name)
   - Query latest candles for the strategy's required timeframes (use primary timeframe, typically H1)
   - Query Candle model: WHERE symbol="XAUUSD" AND timeframe=strategy.required_timeframes[0], ORDER BY timestamp DESC, LIMIT strategy.min_candles + 50 (extra buffer)
   - Convert to DataFrame via candles_to_dataframe()
   - Call strategy.analyze(df) -> list[CandidateSignal]
   - Return candidates (may be empty)
   - Catch InsufficientDataError and log warning, return empty list

2. `async def validate(self, session: AsyncSession, candidates: list[CandidateSignal]) -> list[CandidateSignal]`
   - For each candidate, apply these filters IN ORDER:
     a. **R:R filter (SIG-03):** Reject if float(candidate.risk_reward) < MIN_RR. Log: "Signal rejected: R:R {rr} below minimum {MIN_RR}"
     b. **Confidence filter (SIG-04):** Reject if float(candidate.confidence) < MIN_CONFIDENCE. Log: "Signal rejected: confidence {conf} below minimum {MIN_CONFIDENCE}"
     c. **Dedup filter (SIG-05):** Call _is_duplicate(session, candidate). If True, log "Signal suppressed: duplicate {direction} signal within {DEDUP_WINDOW_HOURS}h window"
     d. **Bias check (SIG-07):** Call _check_directional_bias(session, candidate). If biased, log WARNING but DO NOT reject (informational only). Add note to candidate reasoning.
   - Return list of candidates that passed all filters

3. `async def _is_duplicate(self, session: AsyncSession, candidate: CandidateSignal) -> bool`
   - Query Signal table: WHERE symbol=candidate.symbol AND direction=candidate.direction.value AND status="active" AND created_at >= (now - DEDUP_WINDOW_HOURS)
   - Return True if any matching signal exists
   - Use `datetime.now(timezone.utc) - timedelta(hours=DEDUP_WINDOW_HOURS)` for cutoff

4. `async def _check_directional_bias(self, session: AsyncSession, candidate: CandidateSignal) -> bool`
   - Query last BIAS_WINDOW_SIGNALS signals from Signal table, ordered by created_at DESC
   - Count BUY vs SELL signals
   - If the candidate's direction accounts for > BIAS_SKEW_THRESHOLD of recent signals, return True (biased)
   - If fewer than BIAS_WINDOW_SIGNALS signals exist, return False (not enough data to judge)

5. `def compute_expiry(self, candidate: CandidateSignal) -> datetime`
   - Look up EXPIRY_HOURS[candidate.timeframe], default to 8
   - Return candidate.timestamp + timedelta(hours=expiry_hours)
   - This is called during signal persistence (Plan 05), not during validation

6. `async def expire_stale_signals(self, session: AsyncSession) -> int`
   - UPDATE Signal SET status="expired" WHERE status="active" AND expires_at IS NOT NULL AND expires_at < now()
   - Return count of expired signals
   - Log: "Expired {count} stale signals"
   - This runs before each scanner cycle to clean up

**Important implementation notes:**
- Strategy imports MUST be inside generate() method body (circular import avoidance, established pattern)
- Use `from app.strategies.base import BaseStrategy, CandidateSignal, InsufficientDataError, candles_to_dataframe`
- All datetime operations use timezone.utc
- Float comparisons for R:R and confidence (convert Decimal to float for comparison)
- Do NOT persist signals here -- that happens in the pipeline orchestrator (Plan 05)
- Comprehensive loguru logging for each filter step
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.services.signal_generator import SignalGenerator, MIN_RR, MIN_CONFIDENCE, DEDUP_WINDOW_HOURS, EXPIRY_HOURS; print(f'MIN_RR={MIN_RR}, MIN_CONF={MIN_CONFIDENCE}, DEDUP={DEDUP_WINDOW_HOURS}h'); sg = SignalGenerator(); print('Methods:', [m for m in dir(sg) if not m.startswith('_')])"` -- should print config values and list public methods (generate, validate, compute_expiry, expire_stale_signals)
  </verify>
  <done>
SignalGenerator service exists with: generate() that runs strategy.analyze() on latest candles, validate() that applies R:R >= 2.0, confidence >= 65%, 4-hour dedup window, and directional bias detection. compute_expiry() assigns timeframe-specific expiry (H1=8h, H4=24h). expire_stale_signals() cleans up expired signals.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app.services.signal_generator import SignalGenerator"` imports cleanly
- MIN_RR is 2.0, MIN_CONFIDENCE is 65.0, DEDUP_WINDOW_HOURS is 4
- EXPIRY_HOURS maps H1->8, H4->24
- SignalGenerator has methods: generate, validate, compute_expiry, expire_stale_signals
</verification>

<success_criteria>
- SignalGenerator is importable and instantiable
- R:R threshold is 1:2 (MIN_RR=2.0) per CONTEXT.md decision
- Confidence threshold is 65% per CONTEXT.md decision
- Dedup window is 4 hours per RESEARCH.md recommendation
- Expiry is timeframe-specific (H1=8h, H4=24h)
- Bias detection checks last 20 signals for >75% directional skew
- Stale signal expiry function exists for pipeline cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/04-signal-pipeline/04-02-SUMMARY.md`
</output>
