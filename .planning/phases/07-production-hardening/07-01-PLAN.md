---
phase: 07-production-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - railway.json
  - app/api/status.py
  - app/schemas/status.py
  - app/main.py
autonomous: false
user_setup:
  - service: railway
    why: "Long-running deployment for 24/7 operation"
    env_vars:
      - name: DATABASE_URL
        source: "Railway PostgreSQL plugin -> Variables tab (must use postgresql+asyncpg:// scheme)"
      - name: TWELVE_DATA_API_KEY
        source: "Twelve Data dashboard -> API keys"
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram BotFather"
      - name: TELEGRAM_CHAT_ID
        source: "Telegram chat ID (use @userinfobot)"
      - name: ACCOUNT_BALANCE
        source: "Your prop firm account balance in USD"
    dashboard_config:
      - task: "Add PostgreSQL plugin to Railway project"
        location: "Railway Dashboard -> Project -> + New -> Database -> PostgreSQL"
      - task: "Connect GitHub repo for auto-deploy"
        location: "Railway Dashboard -> Project -> + New -> GitHub Repo"

must_haves:
  truths:
    - "Application starts on Railway with single uvicorn worker and responds to /health"
    - "Alembic migrations run automatically before each deploy via preDeployCommand"
    - "Railway restarts the service automatically on crash (ALWAYS restart policy)"
    - "/status endpoint returns scheduler job states, last data fetch time, active signal count, and DB connectivity"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage Docker build for deterministic deploys"
      contains: "python:3.12-slim"
    - path: "railway.json"
      provides: "Railway config-as-code with healthcheck and restart policy"
      contains: "healthcheckPath"
    - path: ".dockerignore"
      provides: "Excludes unnecessary files from Docker build context"
      contains: "__pycache__"
    - path: "app/api/status.py"
      provides: "Detailed /status diagnostic endpoint"
      exports: ["router"]
    - path: "app/schemas/status.py"
      provides: "Pydantic response model for /status"
      exports: ["StatusResponse"]
  key_links:
    - from: "railway.json"
      to: "Dockerfile"
      via: "builder: DOCKERFILE"
      pattern: "DOCKERFILE"
    - from: "railway.json"
      to: "/health"
      via: "healthcheckPath"
      pattern: "healthcheckPath.*health"
    - from: "app/main.py"
      to: "app/api/status.py"
      via: "include_router"
      pattern: "status_router"
---

<objective>
Create Railway deployment configuration and a detailed /status diagnostic endpoint.

Purpose: Enable the GoldSignal application to deploy to Railway as a long-running service with deterministic Docker builds, automatic migrations, health checks, crash recovery, and operational visibility via /status.

Output: Dockerfile, railway.json, .dockerignore, /status API endpoint
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-production-hardening/07-RESEARCH.md
@app/main.py
@app/config.py
@app/database.py
@app/api/health.py
@app/schemas/health.py
@app/workers/scheduler.py
@requirements.txt
@alembic.ini
@alembic/env.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dockerfile, .dockerignore, and railway.json</name>
  <files>Dockerfile, .dockerignore, railway.json</files>
  <action>
    Create a multi-stage Dockerfile using python:3.12-slim:

    Stage 1 (builder):
    - FROM python:3.12-slim AS builder
    - WORKDIR /app
    - Copy requirements.txt, install dependencies to /app/.venv using pip with --prefix
    - Actually simpler: just install to system in single stage since it's a slim image

    Revised -- single-stage Dockerfile (multi-stage unnecessary for pip-only install):
    - FROM python:3.12-slim
    - WORKDIR /app
    - RUN pip install --no-cache-dir --upgrade pip
    - COPY requirements.txt .
    - RUN pip install --no-cache-dir -r requirements.txt
    - COPY . .
    - ENV PYTHONPATH=/app
    - EXPOSE 8080 (Railway default, but $PORT is injected)
    - CMD ["sh", "-c", "uvicorn app.main:app --host 0.0.0.0 --port ${PORT:-8080}"]

    IMPORTANT: Do NOT hardcode PORT. Railway injects $PORT at runtime. Use shell form to expand variable.
    IMPORTANT: Single uvicorn worker only (APScheduler MemoryJobStore would duplicate jobs with multiple workers).
    IMPORTANT: Set PYTHONPATH=/app so Alembic can find the app module.

    Create .dockerignore:
    - __pycache__/
    - *.py[cod]
    - .venv/
    - venv/
    - .env
    - .git/
    - .gitignore
    - .planning/
    - tests/
    - .pytest_cache/
    - htmlcov/
    - .coverage
    - *.md (except requirements-related)
    - .DS_Store
    - .idea/
    - .vscode/

    Create railway.json config-as-code:
    ```json
    {
      "$schema": "https://railway.com/railway.schema.json",
      "build": {
        "builder": "DOCKERFILE",
        "dockerfilePath": "Dockerfile"
      },
      "deploy": {
        "startCommand": "uvicorn app.main:app --host 0.0.0.0 --port $PORT",
        "healthcheckPath": "/health",
        "healthcheckTimeout": 120,
        "restartPolicyType": "ALWAYS",
        "restartPolicyMaxRetries": 10
      }
    }
    ```

    NOTE on preDeployCommand: Railway's preDeployCommand runs in the build environment, not the deploy environment. For Alembic migrations, set it only if Railway provides DATABASE_URL at build time. The safer approach is to run migrations in the app startup or as a separate Railway service. For simplicity, add preDeployCommand and document that it requires DATABASE_URL available at build time:
    ```
    "preDeployCommand": "PYTHONPATH=/app alembic upgrade head"
    ```

    If Railway does not expose DATABASE_URL at pre-deploy time, the user can remove this and run migrations manually via `railway run alembic upgrade head`.
  </action>
  <verify>
    - Dockerfile exists and contains python:3.12-slim, single uvicorn command, PYTHONPATH=/app
    - .dockerignore exists and excludes __pycache__, .env, .git, tests, .planning
    - railway.json exists with healthcheckPath: "/health", restartPolicyType: "ALWAYS", builder: "DOCKERFILE"
    - Run: docker build -t goldsignal-test . (should succeed if Docker available, otherwise verify file contents)
  </verify>
  <done>
    Dockerfile builds a production image with pip dependencies, single uvicorn worker, and $PORT variable expansion. railway.json configures Railway for Dockerfile builds with health checks, auto-restart, and pre-deploy migrations. .dockerignore excludes development artifacts.
  </done>
</task>

<task type="auto">
  <name>Task 2: /status diagnostic endpoint</name>
  <files>app/schemas/status.py, app/api/status.py, app/main.py</files>
  <action>
    Create app/schemas/status.py with a Pydantic StatusResponse model:
    ```python
    class SchedulerJobInfo(BaseModel):
        id: str
        name: str
        next_run_time: datetime | None
        trigger: str

    class StatusResponse(BaseModel):
        status: str                          # "ok" or "degraded"
        uptime_seconds: float
        database: str                        # "connected" or "disconnected"
        scheduler: str                       # "running" or "stopped"
        jobs: list[SchedulerJobInfo]
        active_signals: int
        last_candle_fetch: datetime | None   # timestamp of most recent candle
        last_signal_generated: datetime | None
        timestamp: datetime
    ```

    Create app/api/status.py with a GET /status endpoint:
    - Import scheduler from app.workers.scheduler
    - Check DB connectivity (SELECT 1, same as /health but catch exceptions gracefully)
    - Query scheduler.get_jobs() and map to SchedulerJobInfo (id, name, next_run_time, trigger type string)
    - Count active signals: SELECT count(*) FROM signals WHERE status = 'active'
    - Get last candle fetch: SELECT MAX(timestamp) FROM candles
    - Get last signal generated: SELECT MAX(created_at) FROM signals
    - Track uptime using a module-level _start_time = datetime.now(UTC) set at import time
    - Set status = "ok" if DB connected and scheduler running, else "degraded"
    - Return StatusResponse

    IMPORTANT: This is a diagnostic endpoint, NOT the health check. Keep /health lightweight (SELECT 1 only). /status does heavier queries.

    Update app/main.py:
    - Import status router: from app.api.status import router as status_router
    - Add: app.include_router(status_router)
  </action>
  <verify>
    - app/schemas/status.py exists with StatusResponse class
    - app/api/status.py exists with GET /status endpoint
    - app/main.py imports and includes status_router
    - grep for "status_router" in app/main.py confirms it's wired
    - grep for "active_signals" in app/api/status.py confirms signal count query
  </verify>
  <done>
    GET /status returns JSON with database connectivity, scheduler job states with next_run_time, active signal count, last candle fetch timestamp, last signal generated timestamp, and uptime. /health remains lightweight for Railway health checks.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Railway deployment configuration (Dockerfile, railway.json, .dockerignore) and /status diagnostic endpoint.

    Before deploying, the user needs to:
    1. Add a PostgreSQL plugin to their Railway project
    2. Connect the GitHub repo to Railway for auto-deploy
    3. Configure environment variables in Railway dashboard
  </what-built>
  <how-to-verify>
    1. Verify /status endpoint works locally:
       - Start the app: PYTHONPATH=. uvicorn app.main:app --port 8000
       - Visit http://localhost:8000/status
       - Confirm it shows scheduler jobs, database status, active signals, uptime

    2. Verify Docker build works:
       - Run: docker build -t goldsignal .
       - Confirm it builds successfully

    3. Deploy to Railway:
       - Push to main branch (or deploy via Railway CLI: railway up)
       - Verify the service starts and stays alive
       - Visit https://[your-railway-url]/health -- should return {"status": "ok"}
       - Visit https://[your-railway-url]/status -- should show full diagnostics

    4. Verify restart behavior:
       - In Railway dashboard, observe the service recovers if it crashes

    IMPORTANT: Set DATABASE_URL in Railway to use postgresql+asyncpg:// scheme (not postgres://).
    Railway PostgreSQL plugin provides DATABASE_URL with postgres:// -- you must override it or add a separate variable using the asyncpg scheme.
  </how-to-verify>
  <resume-signal>Type "approved" if Railway deployment is working and /status returns diagnostics, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
- Dockerfile builds successfully with docker build
- railway.json is valid JSON with required fields
- /health returns 200 with lightweight SELECT 1
- /status returns full diagnostics with scheduler jobs, active signals, DB status
- Single uvicorn worker (no APScheduler duplication)
- $PORT not hardcoded (Railway injects at runtime)
</verification>

<success_criteria>
1. Docker image builds and runs locally with correct startup command
2. railway.json configures DOCKERFILE builder, /health healthcheck, ALWAYS restart, and pre-deploy migrations
3. /status endpoint returns scheduler job list, DB status, active signal count, last candle timestamp, and uptime
4. Application deploys to Railway and stays alive as a long-running service
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-01-SUMMARY.md`
</output>
