---
phase: 06-outcome-tracking-and-feedback
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - app/services/outcome_detector.py
  - tests/test_outcome_detector.py
  - app/workers/jobs.py
  - app/workers/scheduler.py
autonomous: true

must_haves:
  truths:
    - "OutcomeDetector fetches current XAUUSD price via Twelve Data /price endpoint with retry"
    - "Active signals are evaluated against current price every 30 seconds with spread accounting"
    - "SL hit is detected before TP (SL takes priority per decision 03-01)"
    - "TP2 is detected before TP1 when price jumps past both"
    - "Expired signals are detected when current time >= expires_at"
    - "Outcomes are recorded to the outcomes table with correct result, exit_price, pnl_pips, duration"
    - "Signal status is updated from active to the detected outcome (tp1_hit, tp2_hit, sl_hit, expired)"
    - "BUY SL checks bid price; SELL SL checks ask (bid + spread)"
  artifacts:
    - path: "app/services/outcome_detector.py"
      provides: "OutcomeDetector service class"
      exports: ["OutcomeDetector"]
    - path: "tests/test_outcome_detector.py"
      provides: "Unit tests for outcome detection logic"
      min_lines: 150
    - path: "app/workers/jobs.py"
      provides: "check_outcomes() job function"
      contains: "check_outcomes"
    - path: "app/workers/scheduler.py"
      provides: "IntervalTrigger registration for outcome checking"
      contains: "IntervalTrigger"
  key_links:
    - from: "app/services/outcome_detector.py"
      to: "app/models/signal.py"
      via: "Query active signals, update status"
      pattern: "Signal\\.status"
    - from: "app/services/outcome_detector.py"
      to: "app/models/outcome.py"
      via: "Insert outcome records"
      pattern: "Outcome\\("
    - from: "app/services/outcome_detector.py"
      to: "app/services/spread_model.py"
      via: "Get current spread for SL/TP checks"
      pattern: "SessionSpreadModel"
    - from: "app/workers/jobs.py"
      to: "app/services/outcome_detector.py"
      via: "Job function instantiates and runs OutcomeDetector"
      pattern: "OutcomeDetector"
    - from: "app/workers/scheduler.py"
      to: "app/workers/jobs.py"
      via: "IntervalTrigger registers check_outcomes job"
      pattern: "check_outcomes"
---

<objective>
Build the OutcomeDetector service that polls current XAUUSD price every 30 seconds, evaluates all active signals against SL/TP levels with spread accounting, records outcomes to the database, updates signal status, and sends Telegram outcome notifications.

Purpose: This is the core of Phase 6 -- closing the feedback loop by automatically detecting whether trade signals hit their targets or stops. Without this, the system generates signals but never learns if they were correct.

Output: `OutcomeDetector` service class, comprehensive unit tests, `check_outcomes` job function, and 30-second IntervalTrigger scheduler registration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-outcome-tracking-and-feedback/06-RESEARCH.md

# Key existing code to reference:
@app/services/trade_simulator.py (SL/TP checking pattern -- adapt for live price instead of OHLC bars)
@app/services/spread_model.py (SessionSpreadModel.get_spread() -- reuse directly)
@app/models/signal.py (Signal model -- status field, expires_at, direction, entry/SL/TP fields)
@app/models/outcome.py (Outcome model -- result, exit_price, pnl_pips, duration_minutes)
@app/services/telegram_notifier.py (notify_outcome() -- already built, wire it here)
@app/workers/jobs.py (existing job patterns -- follow same try/except and session creation style)
@app/workers/scheduler.py (existing scheduler patterns -- add IntervalTrigger alongside CronTriggers)
@app/config.py (get_settings() for twelve_data_api_key and telegram config)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OutcomeDetector service with TDD</name>
  <files>app/services/outcome_detector.py, tests/test_outcome_detector.py</files>
  <action>
**RED phase -- Write failing tests first** in `tests/test_outcome_detector.py`:

Test cases (all using mocked price fetch and in-memory signal objects):
1. `test_buy_sl_hit` -- BUY signal where bid price drops below SL -> result="sl_hit", status updated, pnl negative
2. `test_buy_tp1_hit` -- BUY signal where bid price rises above TP1 (but below TP2) -> result="tp1_hit"
3. `test_buy_tp2_hit` -- BUY signal where bid price rises above TP2 -> result="tp2_hit" (TP2 takes priority over TP1)
4. `test_sell_sl_hit_with_spread` -- SELL signal where ask price (bid + spread) rises above SL -> result="sl_hit" (TRACK-05 spread accounting)
5. `test_sell_tp1_hit` -- SELL signal where bid price drops below TP1 -> result="tp1_hit"
6. `test_expired_signal` -- Signal where `expires_at` is in the past -> result="expired", exit_price = current price
7. `test_sl_priority_over_tp` -- Price hits BOTH SL and TP in same check -> SL wins (conservative, decision [03-01])
8. `test_no_active_signals` -- No active signals in DB -> returns empty list, no API call made
9. `test_price_fetch_failure` -- API returns None/error -> logs warning, returns empty list, no outcomes recorded
10. `test_pnl_calculation_buy` -- BUY: (exit - entry) / PIP_VALUE = correct pnl_pips
11. `test_pnl_calculation_sell` -- SELL: (entry - exit) / PIP_VALUE = correct pnl_pips
12. `test_duration_minutes` -- duration_minutes = (now - signal.created_at) in minutes
13. `test_signal_status_updated` -- After outcome detected, signal.status changes from "active" to the result string
14. `test_no_outcome_when_price_between_sl_tp` -- Price between SL and TP levels -> no outcome, signal stays active

Use `@pytest.mark.asyncio` and mock the `_fetch_current_price` method (patch or dependency injection). For DB tests, use the existing test patterns from `conftest.py` (per-test engine isolation). For pure logic tests of `_evaluate_signal`, test the method directly with mock Signal objects.

**GREEN phase -- Implement** `app/services/outcome_detector.py`:

```python
class OutcomeDetector:
    PIP_VALUE = 0.10  # XAUUSD pip value (consistent with trade_simulator.py)
    PRICE_ENDPOINT = "https://api.twelvedata.com/price"

    def __init__(self, api_key: str) -> None:
        self.api_key = api_key
        self.spread_model = SessionSpreadModel()

    async def check_outcomes(self, session: AsyncSession) -> list[Outcome]:
        """Main entry point: check all active signals against current price."""
        # 1. Query active signals
        active_signals = await self._get_active_signals(session)
        if not active_signals:
            return []

        # 2. Check for expired signals first (no API call needed)
        # 3. Fetch current price via Twelve Data /price endpoint
        # 4. Get current spread from SessionSpreadModel
        # 5. Evaluate each signal
        # 6. Record outcomes, update signal status
        # 7. Return list of new Outcome objects

    async def _fetch_current_price(self) -> float | None:
        """Fetch latest XAUUSD price from Twelve Data /price REST endpoint.

        Uses httpx (async, already in project) with tenacity retry (3 attempts).
        Returns bid price as float, or None on failure.
        Endpoint: GET /price?symbol=XAU/USD&apikey=...
        Response: {"price": "2650.45"}
        Falls back to None and logs warning on any error.
        """

    def _evaluate_signal(self, signal: Signal, price: float, spread: Decimal) -> str | None:
        """Evaluate if current price triggers any outcome for this signal.

        Priority order (from trade_simulator.py pattern):
        1. Check expiry (time-based) -- always checked first
        2. Check SL -- ALWAYS takes priority over TP (decision [03-01])
        3. Check TP2 -- if price jumped past TP1 to TP2, record tp2_hit
        4. Check TP1

        Spread accounting (TRACK-05):
        - BUY: SL checked against bid (price), TP checked against bid (price)
        - SELL: SL checked against ask (price + spread), TP checked against bid (price)

        Returns result string or None if no outcome.
        """

    async def _record_outcome(self, session: AsyncSession, signal: Signal, result: str, exit_price: float) -> Outcome:
        """Insert Outcome row, update signal.status, return Outcome."""
```

Key implementation details:
- Use `httpx.AsyncClient` for `/price` endpoint (like TelegramNotifier pattern)
- Wrap `_fetch_current_price` with `@retry` from tenacity (3 attempts, exponential backoff, retry on httpx errors)
- PIP_VALUE = 0.10 (consistent with trade_simulator.py and risk_manager.py)
- For expired signals: exit_price = current_price (or entry_price if no price available), pnl calculated from actual exit
- Duration: `(datetime.now(utc) - signal.created_at).total_seconds() // 60`
- Twelve Data symbol format: "XAU/USD" (with slash) for the /price endpoint

**REFACTOR** if needed: ensure clean separation of pure logic (_evaluate_signal) from I/O (_fetch_current_price, DB queries).
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -m pytest tests/test_outcome_detector.py -v`
All 14 tests pass.
  </verify>
  <done>
OutcomeDetector correctly detects SL hits, TP1 hits, TP2 hits, and expiry for both BUY and SELL signals with spread accounting. Signal status is updated and Outcome rows are inserted. All 14+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire check_outcomes job and 30-second scheduler</name>
  <files>app/workers/jobs.py, app/workers/scheduler.py</files>
  <action>
Add `check_outcomes()` async job function to `app/workers/jobs.py` following the exact same pattern as existing jobs:

```python
async def check_outcomes() -> None:
    """Check all active signals for outcome detection.

    Runs every 30 seconds via APScheduler IntervalTrigger. Fetches current
    XAUUSD price, checks against all active signal SL/TP/expiry levels,
    records outcomes, updates signal status, and sends Telegram notifications.

    Creates its own database session. All exceptions are caught at the top
    level to prevent scheduler crashes.
    """
    try:
        settings = get_settings()
        detector = OutcomeDetector(api_key=settings.twelve_data_api_key)

        async with async_session_factory() as session:
            outcomes = await detector.check_outcomes(session)

            if outcomes:
                # Send Telegram notifications for each outcome
                notifier = TelegramNotifier(
                    bot_token=settings.telegram_bot_token,
                    chat_id=settings.telegram_chat_id,
                )
                if notifier.enabled:
                    for outcome in outcomes:
                        signal = await session.get(Signal, outcome.signal_id)
                        if signal:
                            await notifier.notify_outcome(signal, outcome)

                logger.info(
                    "check_outcomes complete | outcomes_detected={}",
                    len(outcomes),
                )
            # Only log at debug level when no outcomes (runs every 30s, avoid log spam)
            else:
                logger.debug("check_outcomes: no outcomes detected")
    except Exception:
        logger.exception("check_outcomes failed")
```

Import at top of jobs.py:
- `from app.services.outcome_detector import OutcomeDetector`
- `from app.services.telegram_notifier import TelegramNotifier` (move from inside run_signal_scanner to top-level import)
- `from app.models.signal import Signal` (if not already imported)

Register in `app/workers/scheduler.py`:
- Import `IntervalTrigger` from `apscheduler.triggers.interval`
- Import `check_outcomes` from `app.workers.jobs`
- Add job registration in `register_jobs()`:

```python
from apscheduler.triggers.interval import IntervalTrigger

scheduler.add_job(
    check_outcomes,
    trigger=IntervalTrigger(seconds=30),
    id="check_outcomes",
    name="Check signal outcomes",
    replace_existing=True,
    max_instances=1,
    coalesce=True,
)
logger.info("Registered job: check_outcomes (every 30 seconds)")
```

Update the final log line to reflect the new total job count (7 instead of 6).

Important: The import of `check_outcomes` in scheduler.py needs to be added to the import line at the top alongside existing imports.
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.workers.scheduler import register_jobs; print('import OK')"`
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.workers.jobs import check_outcomes; print('import OK')"`
Both print "import OK" without errors.
  </verify>
  <done>
check_outcomes job is wired into jobs.py with Telegram notification dispatch, and registered as a 30-second IntervalTrigger in scheduler.py. All imports resolve cleanly. Job follows existing error-handling patterns (top-level try/except).
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_outcome_detector.py -v` -- all tests pass
2. `python -c "from app.services.outcome_detector import OutcomeDetector; print('OK')"` -- imports cleanly
3. `python -c "from app.workers.jobs import check_outcomes; print('OK')"` -- job function accessible
4. `python -c "from app.workers.scheduler import register_jobs; print('OK')"` -- scheduler registers without error
5. Verify OutcomeDetector._evaluate_signal handles all 4 outcome types (sl_hit, tp1_hit, tp2_hit, expired) for both BUY and SELL directions
6. Verify spread accounting: SELL SL uses ask (bid + spread), BUY SL uses bid
7. Verify SL priority: when both SL and TP could trigger, SL wins
</verification>

<success_criteria>
- OutcomeDetector service fully implemented with price fetching, signal evaluation, and outcome recording
- 14+ unit tests covering all outcome types, spread accounting, PnL calculation, and edge cases
- check_outcomes job function wired in jobs.py with Telegram notification dispatch
- 30-second IntervalTrigger registered in scheduler.py
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-outcome-tracking-and-feedback/06-01-SUMMARY.md`
</output>
