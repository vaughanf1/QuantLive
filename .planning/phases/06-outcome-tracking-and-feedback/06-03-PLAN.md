---
phase: 06-outcome-tracking-and-feedback
plan: 03
type: tdd
wave: 3
depends_on: ["06-02"]
files_modified:
  - app/services/feedback_controller.py
  - tests/test_feedback_controller.py
  - app/services/telegram_notifier.py
  - app/services/risk_manager.py
  - app/workers/jobs.py
autonomous: true

must_haves:
  truths:
    - "Degrading strategies (win rate drop >15% or profit factor below 1.0) are auto-deprioritized via is_degraded flag"
    - "Telegram alert is sent when a strategy is flagged as degraded"
    - "Strategies that recover (win rate and profit factor above threshold for 7+ days) have degradation flag cleared automatically"
    - "Circuit breaker halts signal generation after 5+ consecutive losses"
    - "Circuit breaker halts signal generation when drawdown exceeds 2x historical max"
    - "Circuit breaker resets after 24-hour cooldown period"
  artifacts:
    - path: "app/services/feedback_controller.py"
      provides: "FeedbackController service class"
      exports: ["FeedbackController"]
    - path: "tests/test_feedback_controller.py"
      provides: "Unit tests for degradation, recovery, and circuit breaker"
      min_lines: 120
    - path: "app/services/telegram_notifier.py"
      provides: "notify_degradation() method"
      contains: "notify_degradation"
    - path: "app/services/risk_manager.py"
      provides: "Circuit breaker check integrated into risk check flow"
      contains: "circuit_breaker"
  key_links:
    - from: "app/services/feedback_controller.py"
      to: "app/models/strategy_performance.py"
      via: "Read metrics and set is_degraded flag"
      pattern: "is_degraded"
    - from: "app/services/feedback_controller.py"
      to: "app/services/telegram_notifier.py"
      via: "Send degradation alerts"
      pattern: "notify_degradation"
    - from: "app/services/risk_manager.py"
      to: "app/services/feedback_controller.py"
      via: "Check circuit breaker before approving signals"
      pattern: "circuit_breaker"
    - from: "app/workers/jobs.py"
      to: "app/services/feedback_controller.py"
      via: "Run feedback checks after outcome detection"
      pattern: "FeedbackController"
---

<objective>
Build the FeedbackController service that detects strategy degradation, sends Telegram alerts, handles auto-recovery, and implements a circuit breaker to halt signal generation during losing streaks or excessive drawdown.

Purpose: This is the self-improvement safeguard. Without it, the system would continue generating signals from a failing strategy. The circuit breaker prevents catastrophic loss sequences, and degradation detection ensures the system adapts to changing market conditions.

Output: `FeedbackController` service class with degradation/recovery logic and circuit breaker, `notify_degradation()` on TelegramNotifier, circuit breaker integration in RiskManager, comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-outcome-tracking-and-feedback/06-RESEARCH.md
@.planning/phases/06-outcome-tracking-and-feedback/06-01-SUMMARY.md
@.planning/phases/06-outcome-tracking-and-feedback/06-02-SUMMARY.md

# Key existing code:
@app/models/strategy_performance.py (StrategyPerformance -- is_degraded flag)
@app/services/strategy_selector.py (_check_degradation -- adapt pattern for live metrics)
@app/services/risk_manager.py (RiskManager.check(), get_drawdown_metrics() -- integrate circuit breaker)
@app/services/telegram_notifier.py (TelegramNotifier -- add notify_degradation())
@app/workers/jobs.py (check_outcomes, run_signal_scanner -- wire feedback checks)
@app/models/outcome.py (Outcome model -- query for consecutive losses)
@app/models/signal.py (Signal model -- query for loss streak)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FeedbackController with degradation, recovery, and circuit breaker (TDD)</name>
  <files>app/services/feedback_controller.py, tests/test_feedback_controller.py</files>
  <action>
**RED phase -- Write failing tests first** in `tests/test_feedback_controller.py`:

Test cases:
1. `test_detect_degradation_low_win_rate` -- Strategy with live win_rate 15%+ below baseline -> is_degraded=True
2. `test_detect_degradation_low_profit_factor` -- Strategy with profit_factor < 1.0 -> is_degraded=True
3. `test_no_degradation_healthy_strategy` -- Strategy with good metrics -> is_degraded=False
4. `test_auto_recovery_after_7_days` -- Strategy was degraded, but last 7d metrics show win_rate and profit_factor above thresholds -> is_degraded cleared
5. `test_no_recovery_before_7_days` -- Strategy degraded for < 7 days -> stays degraded even if recent metrics look good
6. `test_circuit_breaker_consecutive_losses` -- 5+ consecutive sl_hit/expired outcomes -> circuit_breaker_active=True
7. `test_circuit_breaker_drawdown_exceeded` -- Current drawdown > 2x historical max drawdown -> circuit_breaker_active=True
8. `test_circuit_breaker_not_triggered` -- 3 consecutive losses, drawdown within limits -> circuit_breaker_active=False
9. `test_circuit_breaker_24h_cooldown_reset` -- Circuit breaker was active, 24h passed -> automatically resets
10. `test_circuit_breaker_resets_on_win` -- Circuit breaker active, then a win outcome -> consecutive loss counter resets
11. `test_consecutive_losses_count` -- Mixed sequence [win, loss, loss, loss, loss, loss] -> 5 consecutive losses (from the tail)
12. `test_degradation_flag_persisted` -- After check_degradation, StrategyPerformance.is_degraded is updated in DB

Use mock data and the existing test database patterns. Circuit breaker state is in-memory (module-level or class attribute) for simplicity since APScheduler uses MemoryJobStore.

**GREEN phase -- Implement** `app/services/feedback_controller.py`:

```python
class FeedbackController:
    """Manages strategy degradation, recovery, and circuit breaker.

    Degradation criteria (FEED-03):
        - Live win rate drops >15% below baseline (backtest) win rate
        - Live profit factor < 1.0

    Recovery criteria (FEED-04):
        - Strategy was degraded
        - Last 7 days: win_rate >= baseline - 0.05 AND profit_factor >= 1.0
        - Degradation has been active for >= 7 days

    Circuit breaker (FEED-05):
        - 5+ consecutive losses (sl_hit or expired)
        - OR current drawdown > 2x historical max drawdown
        - Auto-resets after 24-hour cooldown
        - Also resets when consecutive loss count drops below 5 (after a win)
    """

    CONSECUTIVE_LOSS_LIMIT = 5
    DRAWDOWN_MULTIPLIER = 2.0
    COOLDOWN_HOURS = 24
    DEGRADATION_RECOVERY_DAYS = 7
    WIN_RATE_DROP_THRESHOLD = 0.15

    # In-memory circuit breaker state (acceptable per decision: MemoryJobStore)
    _circuit_breaker_active: bool = False
    _circuit_breaker_triggered_at: datetime | None = None

    async def check_degradation(
        self, session: AsyncSession, strategy_id: int
    ) -> tuple[bool, str | None]:
        """Check if a strategy should be flagged as degraded.

        Compares live 30d StrategyPerformance against oldest backtest baseline.
        Updates is_degraded flag in StrategyPerformance table.

        Returns (is_degraded, reason_or_none).
        """

    async def check_recovery(
        self, session: AsyncSession, strategy_id: int
    ) -> bool:
        """Check if a degraded strategy has recovered.

        Recovery requires:
        1. Strategy is currently degraded
        2. Degradation has been active >= 7 days
        3. Last 7d metrics show recovery (win_rate within 5% of baseline, pf >= 1.0)

        Returns True if recovery detected (and clears degradation flag).
        """

    async def check_circuit_breaker(self, session: AsyncSession) -> bool:
        """Check if the circuit breaker should be active.

        Checks:
        1. If currently in cooldown and 24h has passed -> reset
        2. Count consecutive losses from most recent outcomes
        3. Check current drawdown vs 2x historical max

        Returns True if circuit breaker is active (signals should be halted).
        """

    async def _count_consecutive_losses(self, session: AsyncSession) -> int:
        """Count consecutive losses from most recent outcome backwards.

        Queries outcomes ordered by created_at DESC. Counts sl_hit and expired
        results until a win (tp1_hit or tp2_hit) is encountered.
        """

    async def run_checks(self, session: AsyncSession) -> dict:
        """Run all feedback checks. Called after outcome detection.

        Returns summary dict with degradation changes and circuit breaker status.
        """
```

Key implementation details:
- Circuit breaker state: class-level attributes `_circuit_breaker_active` and `_circuit_breaker_triggered_at`. This is acceptable because the app runs as a single process and APScheduler uses MemoryJobStore (decision [01-01]).
- Consecutive losses: query `SELECT result FROM outcomes ORDER BY created_at DESC`, iterate until a win is found.
- Drawdown check: reuse `RiskManager.get_drawdown_metrics()` for current/max drawdown. Compare: current_drawdown > 2 * max_drawdown.
  - Edge case: if max_drawdown is 0 (no history), circuit breaker NOT triggered by drawdown check (no baseline to compare against).
- Degradation baseline: query OLDEST non-walk-forward BacktestResult for the strategy (same pattern as StrategySelector._check_degradation).
- Recovery timing: check StrategyPerformance.calculated_at of the first degraded row. If calculated_at >= 7 days ago, eligible for recovery.
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -m pytest tests/test_feedback_controller.py -v`
All 12 tests pass.
  </verify>
  <done>
FeedbackController correctly detects degradation, handles auto-recovery after 7+ days, and implements circuit breaker with 5-loss and 2x-drawdown triggers plus 24h cooldown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add notify_degradation to TelegramNotifier, wire circuit breaker into RiskManager, connect to jobs.py</name>
  <files>app/services/telegram_notifier.py, app/services/risk_manager.py, app/workers/jobs.py</files>
  <action>
**Part A: Add notify_degradation to TelegramNotifier**

Add a new formatting method and fire-and-forget wrapper to `app/services/telegram_notifier.py`:

```python
def format_degradation(self, strategy_name: str, reason: str, is_recovery: bool = False) -> str:
    """Format a degradation or recovery alert as HTML.

    Args:
        strategy_name: Name of the affected strategy.
        reason: Why degradation was detected or recovery occurred.
        is_recovery: True for recovery alerts, False for degradation.
    """
    if is_recovery:
        return (
            f"üîÑ <b>Strategy Recovered: {strategy_name}</b>\n\n"
            f"<i>{reason}</i>"
        )
    return (
        f"‚ö†Ô∏è <b>Strategy Degraded: {strategy_name}</b>\n\n"
        f"<b>Reason:</b> {reason}\n\n"
        f"<i>Strategy has been auto-deprioritized. "
        f"Will auto-recover if metrics improve over 7+ days.</i>"
    )

async def notify_degradation(
    self, strategy_name: str, reason: str, is_recovery: bool = False
) -> None:
    """Send a degradation/recovery alert via Telegram. Never raises."""
    if not self.enabled:
        logger.debug("Telegram disabled, skipping degradation notification")
        return
    try:
        text = self.format_degradation(strategy_name, reason, is_recovery)
        await self._send_message(text)
        label = "recovery" if is_recovery else "degradation"
        logger.info(
            "Telegram {} notification sent for '{}'",
            label, strategy_name,
        )
    except Exception:
        logger.exception(
            "Telegram degradation notification failed for '{}'",
            strategy_name,
        )
```

Also add a circuit breaker notification:

```python
def format_circuit_breaker(self, reason: str, active: bool) -> str:
    """Format circuit breaker activation/deactivation alert."""
    if active:
        return (
            f"üõë <b>CIRCUIT BREAKER ACTIVATED</b>\n\n"
            f"<b>Reason:</b> {reason}\n\n"
            f"<i>Signal generation halted. Auto-resets after 24 hours.</i>"
        )
    return (
        f"‚úÖ <b>Circuit Breaker Reset</b>\n\n"
        f"<i>Signal generation resumed. {reason}</i>"
    )

async def notify_circuit_breaker(self, reason: str, active: bool) -> None:
    """Send circuit breaker alert. Never raises."""
    if not self.enabled:
        return
    try:
        text = self.format_circuit_breaker(reason, active)
        await self._send_message(text)
        logger.info("Telegram circuit breaker notification sent (active={})", active)
    except Exception:
        logger.exception("Telegram circuit breaker notification failed")
```

**Part B: Integrate circuit breaker into RiskManager**

Add a circuit breaker check at the VERY START of `RiskManager.check()`, before the daily loss limit check:

```python
# In RiskManager.check(), at the top before daily loss check:
from app.services.feedback_controller import FeedbackController

# 0. Check circuit breaker (FEED-05)
feedback = FeedbackController()
circuit_active = await feedback.check_circuit_breaker(session)
if circuit_active:
    logger.warning("Circuit breaker active, suppressing all signal generation")
    for candidate in candidates:
        results.append((
            candidate,
            RiskCheckResult(
                approved=False,
                rejection_reason="Circuit breaker active: signal generation halted",
            ),
        ))
    return results
```

Import FeedbackController at the top of risk_manager.py. To avoid circular imports, use a lazy import inside the method if needed.

**Part C: Wire FeedbackController into check_outcomes job**

Modify `check_outcomes()` in `app/workers/jobs.py` to run feedback checks after outcomes are detected:

```python
# After outcomes are detected and PerformanceTracker has run (via OutcomeDetector):
if outcomes:
    # ... existing Telegram notification code ...

    # Run feedback checks (degradation detection, circuit breaker)
    from app.services.feedback_controller import FeedbackController
    feedback = FeedbackController()

    # Check degradation for affected strategies
    strategy_ids = set()
    for outcome in outcomes:
        signal = await session.get(Signal, outcome.signal_id)
        if signal:
            strategy_ids.add(signal.strategy_id)

    notifier = TelegramNotifier(
        bot_token=settings.telegram_bot_token,
        chat_id=settings.telegram_chat_id,
    )

    for sid in strategy_ids:
        # Look up strategy name
        strat_row = await session.get(StrategyModel, sid)
        strat_name = strat_row.name if strat_row else f"strategy_{sid}"

        # Check degradation
        is_degraded, reason = await feedback.check_degradation(session, sid)
        if is_degraded and reason:
            await notifier.notify_degradation(strat_name, reason)

        # Check recovery
        recovered = await feedback.check_recovery(session, sid)
        if recovered:
            await notifier.notify_degradation(
                strat_name, "Metrics recovered above thresholds", is_recovery=True
            )

    # Check circuit breaker
    cb_active = await feedback.check_circuit_breaker(session)
    # Notification for circuit breaker state changes handled inside FeedbackController
```

Import StrategyModel (if not already imported) at top of jobs.py.
  </action>
  <verify>
Run: `cd /Users/vaughanfawcett/TradingView && python -m pytest tests/test_feedback_controller.py tests/test_outcome_detector.py tests/test_performance_tracker.py -v`
All tests pass.
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.services.telegram_notifier import TelegramNotifier; t = TelegramNotifier('', ''); print(hasattr(t, 'notify_degradation'), hasattr(t, 'notify_circuit_breaker'))"`
Prints: True True
Run: `cd /Users/vaughanfawcett/TradingView && python -c "from app.services.risk_manager import RiskManager; print('OK')"`
Prints: OK
  </verify>
  <done>
TelegramNotifier has notify_degradation() and notify_circuit_breaker() methods. RiskManager checks circuit breaker before all other risk checks. FeedbackController is wired into the check_outcomes job to run degradation/recovery/circuit-breaker checks after every outcome batch. The complete feedback loop is operational.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_feedback_controller.py -v` -- all 12 tests pass
2. `python -m pytest tests/ -v` -- full test suite passes (no regressions)
3. FeedbackController detects degradation when win_rate drops >15% or profit_factor < 1.0
4. Auto-recovery clears degradation after 7+ days when metrics improve
5. Circuit breaker activates on 5+ consecutive losses OR 2x max drawdown
6. Circuit breaker resets after 24h cooldown
7. RiskManager.check() returns rejections when circuit breaker is active
8. Telegram notifications fire for degradation, recovery, and circuit breaker events
9. No circular imports between feedback_controller <-> risk_manager (lazy import used if needed)
</verification>

<success_criteria>
- FeedbackController detects strategy degradation and auto-recovery
- Circuit breaker halts signals after 5+ consecutive losses or 2x max drawdown
- Circuit breaker auto-resets after 24h cooldown
- TelegramNotifier sends degradation, recovery, and circuit breaker alerts
- RiskManager integrates circuit breaker check before all other risk checks
- FeedbackController wired into check_outcomes job for continuous monitoring
- All tests pass including existing test suites
</success_criteria>

<output>
After completion, create `.planning/phases/06-outcome-tracking-and-feedback/06-03-SUMMARY.md`
</output>
