---
phase: 03-backtesting-engine
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/services/backtester.py
  - app/services/walk_forward.py
  - app/models/backtest_result.py
  - alembic/versions/add_walk_forward_fields.py
autonomous: true

must_haves:
  truths:
    - "BacktestRunner runs any strategy's analyze() on rolling 30-day and 60-day windows of H1 candle data and collects SimulatedTrades"
    - "Backtester uses the EXACT same strategy.analyze() code path as live signal generation -- no separate backtest-only strategy implementations"
    - "WalkForwardValidator splits data 80/20 and flags strategies where OOS metrics degrade below 50% of IS metrics"
    - "Walk-forward skips overfitting detection when fewer than 5 trades in OOS to avoid noisy results"
  artifacts:
    - path: "app/services/backtester.py"
      provides: "BacktestRunner class with run_rolling_backtest and run_full_backtest methods"
      contains: "run_rolling_backtest"
    - path: "app/services/walk_forward.py"
      provides: "WalkForwardValidator class and WalkForwardResult dataclass"
      contains: "validate"
    - path: "app/models/backtest_result.py"
      provides: "Updated BacktestResult model with walk-forward fields"
      contains: "is_walk_forward"
    - path: "alembic/versions/"
      provides: "Migration adding walk-forward columns to backtest_results"
  key_links:
    - from: "app/services/backtester.py"
      to: "app/services/trade_simulator.py"
      via: "TradeSimulator.simulate_trade() for trade outcome determination"
      pattern: "from app\\.services\\.trade_simulator import"
    - from: "app/services/backtester.py"
      to: "app/strategies/base.py"
      via: "strategy.analyze(candles) -- same code path as live"
      pattern: "strategy\\.analyze\\("
    - from: "app/services/walk_forward.py"
      to: "app/services/metrics_calculator.py"
      via: "MetricsCalculator.compute() for IS and OOS metric comparison"
      pattern: "from app\\.services\\.metrics_calculator import"
---

<objective>
Build the BacktestRunner orchestrator that runs strategies on rolling windows and collects simulated trades, and the WalkForwardValidator that detects overfitting via 80/20 IS/OOS comparison. Add walk-forward fields to BacktestResult via Alembic migration.

Purpose: This plan wires the simulation components from Plan 03-01 into a complete backtesting pipeline that can evaluate any strategy on historical data and detect when a strategy is overfitted to past conditions.

Output: BacktestRunner service (rolling 30-day and 60-day windows), WalkForwardValidator service (80/20 split with degradation threshold), and updated DB schema.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-backtesting-engine/03-RESEARCH.md
@.planning/phases/03-backtesting-engine/03-01-SUMMARY.md

@app/strategies/base.py -- BaseStrategy.analyze(), CandidateSignal, InsufficientDataError, candles_to_dataframe
@app/services/trade_simulator.py -- TradeSimulator, SimulatedTrade, TradeOutcome (from Plan 03-01)
@app/services/spread_model.py -- SessionSpreadModel (from Plan 03-01)
@app/services/metrics_calculator.py -- MetricsCalculator, BacktestMetrics (from Plan 03-01)
@app/models/backtest_result.py -- Current BacktestResult model
@app/models/candle.py -- Candle ORM model
@app/database.py -- async_session_factory, get_session
</context>

<tasks>

<task type="auto">
  <name>Task 1: BacktestRunner with rolling window logic</name>
  <files>app/services/backtester.py</files>
  <action>
Create `app/services/backtester.py` with:

**BacktestRunner class:**

Constructor takes:
- `simulator: TradeSimulator` (default: `TradeSimulator()`)
- `spread_model: SessionSpreadModel` (default: `SessionSpreadModel()`)
- `metrics_calculator: MetricsCalculator` (default: `MetricsCalculator()`)

Methods:

1. `run_rolling_backtest(self, strategy: BaseStrategy, candles: pd.DataFrame, window_days: int, step_days: int = 1) -> list[SimulatedTrade]`:
   - This is the core rolling-window loop that satisfies BACK-01 and BACK-02
   - Convert `window_days` to candle count: `window_candles = window_days * 24` (H1 timeframe = 24 candles/day)
   - Validate: if `len(candles) < window_candles + TradeSimulator.MAX_BARS_FORWARD`, log warning and return empty list
   - Step size: `step_candles = step_days * 24`
   - Loop: `for start_idx in range(0, len(candles) - window_candles - TradeSimulator.MAX_BARS_FORWARD, step_candles)`:
     - `end_idx = start_idx + window_candles`
     - `window = candles.iloc[start_idx:end_idx].reset_index(drop=True)`
     - Call `strategy.analyze(window)` wrapped in try/except for InsufficientDataError (skip window, continue)
     - For each CandidateSignal returned:
       - Find the signal's bar index in the FULL candle set (not the window): the signal comes from the analysis window, so simulate starting from `end_idx` (first bar after the window)
       - Get spread: `spread = self.spread_model.get_spread(signal.timestamp)`
       - Call `self.simulator.simulate_trade(signal, candles, end_idx - 1, spread)` (end_idx - 1 is the last bar of the analysis window; simulation starts from end_idx)
       - Append result to trades list
   - Return all SimulatedTrade objects

2. `run_full_backtest(self, strategy: BaseStrategy, candles: pd.DataFrame, window_days: int, step_days: int = 1) -> tuple[BacktestMetrics, list[SimulatedTrade]]`:
   - Calls `run_rolling_backtest()` to get trades
   - Calls `self.metrics_calculator.compute(trades)` to get metrics
   - Returns (metrics, trades) tuple
   - Logs: strategy name, window_days, total_trades, win_rate, profit_factor

3. `run_all_strategies(self, candles: pd.DataFrame, window_days_list: list[int] = [30, 60]) -> dict[str, dict[int, tuple[BacktestMetrics, list[SimulatedTrade]]]]`:
   - Iterates over all registered strategies from `BaseStrategy.get_registry()`
   - For each strategy and each window_days, calls `run_full_backtest()`
   - Returns nested dict: `{strategy_name: {window_days: (metrics, trades)}}`
   - Catches and logs any exceptions per strategy (does not abort other strategies)

**Critical constraints:**
- The rolling window calls `strategy.analyze(window)` -- the EXACT same code path used for live signal generation (BACK-02)
- Signals are simulated against candles AFTER the analysis window (no look-ahead bias)
- Use loguru for all logging (consistent with project)
- All methods are synchronous (no async) because strategy.analyze() is synchronous and pandas operations are CPU-bound
  </action>
  <verify>
```bash
cd /Users/vaughanfawcett/TradingView && python -c "
from app.services.backtester import BacktestRunner
from app.services.trade_simulator import TradeSimulator
from app.services.spread_model import SessionSpreadModel
from app.services.metrics_calculator import MetricsCalculator

runner = BacktestRunner()
assert hasattr(runner, 'run_rolling_backtest')
assert hasattr(runner, 'run_full_backtest')
assert hasattr(runner, 'run_all_strategies')
assert isinstance(runner.simulator, TradeSimulator)
assert isinstance(runner.spread_model, SessionSpreadModel)
assert isinstance(runner.metrics_calculator, MetricsCalculator)
print('BacktestRunner: INSTANTIATION PASSED')
"
```
  </verify>
  <done>BacktestRunner runs strategies on rolling windows using the same analyze() code path as live, collects SimulatedTrades, and computes BacktestMetrics. run_all_strategies iterates all registered strategies with both 30-day and 60-day windows.</done>
</task>

<task type="auto">
  <name>Task 2: WalkForwardValidator and BacktestResult migration</name>
  <files>app/services/walk_forward.py, app/models/backtest_result.py, alembic/versions/</files>
  <action>
**File 1: `app/services/walk_forward.py`**

1. **WalkForwardResult dataclass**:
   - `is_metrics: BacktestMetrics` -- in-sample metrics (80% of data)
   - `oos_metrics: BacktestMetrics` -- out-of-sample metrics (20% of data)
   - `is_overfitted: bool` -- True if OOS degrades significantly vs IS
   - `wfe_win_rate: float | None` -- walk-forward efficiency for win rate (OOS/IS)
   - `wfe_profit_factor: float | None` -- walk-forward efficiency for profit factor
   - `insufficient_oos_trades: bool` -- True if OOS had fewer than MIN_OOS_TRADES

2. **WalkForwardValidator class**:
   - `DEGRADATION_THRESHOLD = 0.5` -- OOS metric < 50% of IS metric = overfitting flag
   - `MIN_OOS_TRADES = 5` -- minimum trades in OOS before comparing
   - Constructor takes `runner: BacktestRunner` (no default -- must be injected)

   - `validate(self, strategy: BaseStrategy, candles: pd.DataFrame, window_days: int = 30) -> WalkForwardResult`:
     - Split candles 80/20: `split_idx = int(len(candles) * 0.8)`
     - `is_candles = candles.iloc[:split_idx].reset_index(drop=True)`
     - `oos_candles = candles.iloc[split_idx:].reset_index(drop=True)`
     - Run `self.runner.run_full_backtest(strategy, is_candles, window_days)` for IS
     - Run `self.runner.run_full_backtest(strategy, oos_candles, window_days)` for OOS
     - If OOS total_trades < MIN_OOS_TRADES: return with `insufficient_oos_trades=True`, `is_overfitted=False`, WFE values = None
     - Calculate WFE ratios:
       - `wfe_win_rate = float(oos_metrics.win_rate) / float(is_metrics.win_rate)` if IS win_rate > 0, else None
       - `wfe_profit_factor = float(oos_metrics.profit_factor) / float(is_metrics.profit_factor)` if IS profit_factor > 0, else None
     - `is_overfitted = False`. Set to True if:
       - wfe_win_rate is not None AND wfe_win_rate < DEGRADATION_THRESHOLD
       - OR wfe_profit_factor is not None AND wfe_profit_factor < DEGRADATION_THRESHOLD
     - Return WalkForwardResult

**File 2: Update `app/models/backtest_result.py`**

Add these nullable columns to BacktestResult model:
- `is_walk_forward: Mapped[Optional[bool]]` -- `mapped_column(Boolean, nullable=True, default=False)`
- `is_overfitted: Mapped[Optional[bool]]` -- `mapped_column(Boolean, nullable=True, default=None)`
- `walk_forward_efficiency: Mapped[Optional[Decimal]]` -- `mapped_column(Numeric(10, 4), nullable=True)`
- `spread_model: Mapped[Optional[str]]` -- `mapped_column(String(20), nullable=True)` -- e.g. "session_aware"

Import `Boolean` from sqlalchemy.

**File 3: Alembic migration**

Generate migration:
```bash
cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m alembic revision --autogenerate -m "add walk forward fields to backtest results"
```

Then run:
```bash
cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m alembic upgrade head
```

**Critical constraints:**
- Walk-forward validation uses the same BacktestRunner.run_full_backtest() -- no separate implementation
- IS and OOS each get their own independent rolling backtest run
- Skip overfitting detection with < 5 OOS trades to avoid noisy results
- All new DB columns are nullable to preserve backward compatibility
  </action>
  <verify>
```bash
cd /Users/vaughanfawcett/TradingView && python -c "
from app.services.walk_forward import WalkForwardValidator, WalkForwardResult
from app.services.backtester import BacktestRunner
from app.services.metrics_calculator import BacktestMetrics
from app.models.backtest_result import BacktestResult

# Verify WalkForwardValidator instantiates
runner = BacktestRunner()
wfv = WalkForwardValidator(runner=runner)
assert wfv.DEGRADATION_THRESHOLD == 0.5
assert wfv.MIN_OOS_TRADES == 5
print('WalkForwardValidator: PASSED')

# Verify new BacktestResult columns
assert hasattr(BacktestResult, 'is_walk_forward')
assert hasattr(BacktestResult, 'is_overfitted')
assert hasattr(BacktestResult, 'walk_forward_efficiency')
assert hasattr(BacktestResult, 'spread_model')
print('BacktestResult columns: PASSED')
print('ALL CHECKS PASSED')
" && PYTHONPATH=. python -m alembic current
```
  </verify>
  <done>WalkForwardValidator splits data 80/20, runs independent backtests on each half, computes WFE ratios, and flags overfitting when OOS metrics degrade > 50% from IS. BacktestResult has new walk-forward columns. Migration applied successfully.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.services.backtester import BacktestRunner; from app.services.walk_forward import WalkForwardValidator"` -- both import cleanly
2. BacktestRunner.run_rolling_backtest calls strategy.analyze() (the same code path as live signal generation)
3. WalkForwardValidator.validate() returns correct is_overfitted flag based on WFE threshold
4. BacktestResult model has 4 new nullable columns (is_walk_forward, is_overfitted, walk_forward_efficiency, spread_model)
5. Alembic migration is at head with new columns in database
</verification>

<success_criteria>
- BacktestRunner.run_rolling_backtest() slides a window across candles and calls strategy.analyze() on each window position
- Signals are simulated against bars AFTER the analysis window (no look-ahead)
- run_all_strategies() iterates all registered strategies with 30-day and 60-day windows
- WalkForwardValidator splits 80/20 and correctly identifies when OOS performance degrades below 50% of IS
- Walk-forward skips overfitting check when OOS has < 5 trades
- BacktestResult DB model has new walk-forward fields, migration applied
</success_criteria>

<output>
After completion, create `.planning/phases/03-backtesting-engine/03-02-SUMMARY.md`
</output>
