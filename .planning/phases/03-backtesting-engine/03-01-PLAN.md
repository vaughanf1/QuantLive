---
phase: 03-backtesting-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/trade_simulator.py
  - app/services/spread_model.py
  - app/services/metrics_calculator.py
autonomous: true

must_haves:
  truths:
    - "TradeSimulator walks CandidateSignal trades forward through OHLC bars and determines outcome (SL_HIT, TP1_HIT, TP2_HIT, EXPIRED)"
    - "SL takes priority over TP when both could be hit in the same bar (conservative assumption)"
    - "SessionSpreadModel returns session-appropriate spread costs based on timestamp (Asian ~5 pips, London/NY ~3 pips, Overlap ~2 pips)"
    - "MetricsCalculator computes all 5 required metrics (win rate, profit factor, Sharpe ratio, max drawdown, expectancy) from a list of SimulatedTrades"
  artifacts:
    - path: "app/services/trade_simulator.py"
      provides: "TradeSimulator class, SimulatedTrade dataclass, TradeOutcome enum"
      contains: "simulate_trade"
    - path: "app/services/spread_model.py"
      provides: "SessionSpreadModel class with session-aware spread lookup"
      contains: "get_spread"
    - path: "app/services/metrics_calculator.py"
      provides: "MetricsCalculator class, BacktestMetrics dataclass"
      contains: "compute"
  key_links:
    - from: "app/services/trade_simulator.py"
      to: "app/strategies/base.py"
      via: "CandidateSignal and Direction imports"
      pattern: "from app\\.strategies\\.base import"
    - from: "app/services/spread_model.py"
      to: "app/strategies/helpers/session_filter.py"
      via: "get_active_sessions() for session detection"
      pattern: "from app\\.strategies\\.helpers\\.session_filter import get_active_sessions"
---

<objective>
Build the three core backtesting components: TradeSimulator (walks CandidateSignals through OHLC bars to determine SL/TP outcomes), SessionSpreadModel (session-aware spread costs for XAUUSD), and MetricsCalculator (computes win rate, profit factor, Sharpe ratio, max drawdown, expectancy).

Purpose: These are the foundational building blocks that the BacktestRunner (Plan 03-02) will orchestrate. Isolating them ensures each is independently testable and reusable.

Output: Three service modules with data classes that transform CandidateSignals + OHLC data into SimulatedTrades and BacktestMetrics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-backtesting-engine/03-RESEARCH.md

@app/strategies/base.py -- CandidateSignal, Direction, BaseStrategy, candles_to_dataframe
@app/strategies/helpers/session_filter.py -- get_active_sessions(), SESSIONS dict
@app/models/backtest_result.py -- BacktestResult ORM model (target for persistence in Plan 03-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: TradeSimulator with SimulatedTrade and TradeOutcome</name>
  <files>app/services/trade_simulator.py</files>
  <action>
Create `app/services/trade_simulator.py` with:

1. **TradeOutcome enum** (str, Enum): `TP1_HIT`, `TP2_HIT`, `SL_HIT`, `EXPIRED`

2. **SimulatedTrade dataclass**:
   - `signal: CandidateSignal` -- the original signal
   - `outcome: TradeOutcome`
   - `exit_price: Decimal` -- price at which trade exited
   - `pnl_pips: Decimal` -- PnL in pips (1 pip = $0.10 for XAUUSD)
   - `bars_held: int` -- how many bars the trade was open
   - `spread_cost: Decimal` -- spread applied at entry

3. **TradeSimulator class** with:
   - `MAX_BARS_FORWARD = 72` (3 days at H1 = 72 bars max hold)
   - `PIP_VALUE = 0.10` (XAUUSD: 1 pip = $0.10 price movement)

   - `simulate_trade(self, signal: CandidateSignal, candles: pd.DataFrame, signal_bar_idx: int, spread: Decimal) -> SimulatedTrade`:
     - Convert signal prices to float for internal math: `entry = float(signal.entry_price)`, `sl = float(signal.stop_loss)`, `tp1 = float(signal.take_profit_1)`, `tp2 = float(signal.take_profit_2)`
     - For BUY: adjust entry UP by spread (buying at ask = bid + spread)
     - For SELL: no entry adjustment (but SL check uses high + spread on ask side)
     - Loop from `signal_bar_idx + 1` to `min(signal_bar_idx + 1 + MAX_BARS_FORWARD, len(candles))`
     - On each bar, check in this priority order:
       a. **SL first (conservative):** BUY: `bar_low <= sl`; SELL: `bar_high + float(spread) >= sl`
       b. **TP2 next:** BUY: `bar_high >= tp2`; SELL: `bar_low <= tp2`
       c. **TP1 last:** BUY: `bar_high >= tp1`; SELL: `bar_low <= tp1`
     - SL takes priority when both SL and TP could be hit in the same bar
     - Calculate `pnl` as `(exit - adjusted_entry)` for BUY, `(adjusted_entry - exit)` for SELL
     - Convert pnl to pips: `pnl_pips = pnl / PIP_VALUE`
     - Convert exit_price and pnl_pips to Decimal at boundary: `Decimal(str(round(x, 2)))`
     - If loop exhausts without hit: outcome = EXPIRED, exit at last bar's close, calculate PnL accordingly

   - `simulate_signals(self, signals: list[tuple[CandidateSignal, int]], candles: pd.DataFrame, spread_model) -> list[SimulatedTrade]`:
     - Convenience method that takes a list of (signal, signal_bar_idx) tuples
     - Calls `spread_model.get_spread(signal.timestamp)` for each signal
     - Returns list of all SimulatedTrades

**Critical constraints:**
- Use float for ALL internal calculations (candle DataFrame is float64 from candles_to_dataframe)
- Convert to Decimal(str(round(x, 2))) ONLY at the SimulatedTrade construction boundary
- Never access bars at or before signal_bar_idx for outcome determination (no look-ahead bias)
- SL ALWAYS takes priority over TP when both could hit in same bar
  </action>
  <verify>
```bash
cd /Users/vaughanfawcett/TradingView && python -c "
from app.services.trade_simulator import TradeSimulator, TradeOutcome, SimulatedTrade
from app.strategies.base import CandidateSignal, Direction
from decimal import Decimal
import pandas as pd
from datetime import datetime, timezone

# Verify classes exist and instantiate
sim = TradeSimulator()
assert sim.MAX_BARS_FORWARD == 72
assert sim.PIP_VALUE == 0.10

# Create test signal and candles
signal = CandidateSignal(
    strategy_name='test', timeframe='H1', direction=Direction.BUY,
    entry_price=Decimal('2650.00'), stop_loss=Decimal('2645.00'),
    take_profit_1=Decimal('2660.00'), take_profit_2=Decimal('2670.00'),
    risk_reward=Decimal('2.00'), confidence=Decimal('70'),
    reasoning='test', timestamp=datetime(2025,1,1, tzinfo=timezone.utc)
)

# Candles where TP1 is hit on bar 2
candles = pd.DataFrame({
    'timestamp': [datetime(2025,1,1,h, tzinfo=timezone.utc) for h in range(5)],
    'open': [2650.0, 2651.0, 2652.0, 2655.0, 2658.0],
    'high': [2651.0, 2653.0, 2661.0, 2662.0, 2663.0],
    'low':  [2649.0, 2650.0, 2651.0, 2654.0, 2657.0],
    'close':[2650.5, 2652.0, 2660.0, 2661.0, 2662.0],
})

trade = sim.simulate_trade(signal, candles, 0, Decimal('0.30'))
assert trade.outcome == TradeOutcome.TP1_HIT, f'Expected TP1_HIT, got {trade.outcome}'
assert trade.bars_held == 2
assert isinstance(trade.pnl_pips, Decimal)
print('TradeSimulator: ALL CHECKS PASSED')
"
```
  </verify>
  <done>TradeSimulator correctly simulates BUY and SELL trades through OHLC bars, SL takes priority over TP in same bar, EXPIRED outcome works when MAX_BARS_FORWARD exhausted, all outputs use Decimal at the boundary</done>
</task>

<task type="auto">
  <name>Task 2: SessionSpreadModel and MetricsCalculator</name>
  <files>app/services/spread_model.py, app/services/metrics_calculator.py</files>
  <action>
**File 1: `app/services/spread_model.py`**

Create `SessionSpreadModel` class:

- `SESSION_SPREADS` dict mapping session name to Decimal spread in price units:
  - `"overlap": Decimal("0.20")` -- London/NY overlap: tightest (~2 pips)
  - `"london": Decimal("0.30")` -- London session (~3 pips)
  - `"new_york": Decimal("0.30")` -- NY session (~3 pips)
  - `"asian": Decimal("0.50")` -- Asian session: widest (~5 pips)
- `DEFAULT_SPREAD = Decimal("0.50")` -- off-session / unknown: conservative
- `get_spread(self, timestamp: datetime) -> Decimal`:
  - Calls `get_active_sessions(timestamp)` from `app.strategies.helpers.session_filter`
  - If no sessions active, return DEFAULT_SPREAD
  - If multiple sessions active, return the tightest (minimum) spread
  - Returns the Decimal spread value

**File 2: `app/services/metrics_calculator.py`**

1. **BacktestMetrics dataclass**:
   - `win_rate: Decimal` -- 0-1 range (0.65 = 65%)
   - `profit_factor: Decimal` -- gross_profit / gross_loss (>1 = profitable)
   - `sharpe_ratio: Decimal` -- annualized risk-adjusted return
   - `max_drawdown: Decimal` -- worst peak-to-trough decline (absolute pips)
   - `expectancy: Decimal` -- average expected PnL per trade in pips
   - `total_trades: int`

2. **MetricsCalculator class**:
   - `TRADING_DAYS_PER_YEAR = 252`
   - `compute(self, trades: list[SimulatedTrade]) -> BacktestMetrics`:
     - If empty trades list: return zeroed BacktestMetrics with total_trades=0
     - Extract `pnls = [float(t.pnl_pips) for t in trades]`
     - **Win rate:** `len(wins) / len(pnls)` where wins are pnl > 0
     - **Profit factor:** `sum(wins) / abs(sum(losses))`. If no losses, cap at 9999.9999. If no wins, 0.
     - **Expectancy:** `(avg_win * win_rate) - (avg_loss * loss_rate)` in pips
     - **Sharpe ratio:** `(mean(pnls) / std(pnls, ddof=1)) * sqrt(min(len(pnls), 252))`. If std is 0 or only 1 trade, Sharpe = 0.
     - **Max drawdown (absolute pips):** Compute cumulative PnL curve via `np.cumsum(pnls)`. Track running peak via `np.maximum.accumulate(cumulative)`. Drawdown = `peak - cumulative`. Max drawdown = `np.max(drawdown)`. If no drawdown, 0.
     - Convert all results to Decimal(str(round(x, 4))) at output boundary
     - Use numpy for vectorized operations (np.mean, np.std, np.cumsum, np.maximum.accumulate)

**Critical constraints:**
- Use float internally for all math, Decimal at boundary only
- Handle edge cases: empty trades, all wins (no losses), all losses (no wins), single trade
- Cap profit_factor at 9999.9999 for DB Numeric(10,4) compatibility
- Max drawdown is in absolute pips (not percentage) -- easier to interpret for XAUUSD
  </action>
  <verify>
```bash
cd /Users/vaughanfawcett/TradingView && python -c "
from app.services.spread_model import SessionSpreadModel
from app.services.metrics_calculator import MetricsCalculator, BacktestMetrics
from app.services.trade_simulator import SimulatedTrade, TradeOutcome
from app.strategies.base import CandidateSignal, Direction
from decimal import Decimal
from datetime import datetime, timezone

# Test spread model
sm = SessionSpreadModel()
# 14:00 UTC = overlap session -> 0.20
assert sm.get_spread(datetime(2025,1,1,14,0, tzinfo=timezone.utc)) == Decimal('0.20')
# 03:00 UTC = asian session -> 0.50
assert sm.get_spread(datetime(2025,1,1,3,0, tzinfo=timezone.utc)) == Decimal('0.50')
print('SpreadModel: PASSED')

# Test metrics calculator
mc = MetricsCalculator()

# Empty trades
m = mc.compute([])
assert m.total_trades == 0
assert m.win_rate == Decimal('0')

# Create mock trades
def make_trade(pnl_pips):
    sig = CandidateSignal(
        strategy_name='test', timeframe='H1', direction=Direction.BUY,
        entry_price=Decimal('2650.00'), stop_loss=Decimal('2645.00'),
        take_profit_1=Decimal('2660.00'), take_profit_2=Decimal('2670.00'),
        risk_reward=Decimal('2.00'), confidence=Decimal('70'),
        reasoning='test', timestamp=datetime(2025,1,1, tzinfo=timezone.utc)
    )
    outcome = TradeOutcome.TP1_HIT if pnl_pips > 0 else TradeOutcome.SL_HIT
    return SimulatedTrade(
        signal=sig, outcome=outcome,
        exit_price=Decimal('2660.00'), pnl_pips=Decimal(str(pnl_pips)),
        bars_held=5, spread_cost=Decimal('0.30')
    )

trades = [make_trade(100), make_trade(50), make_trade(-50), make_trade(80)]
m = mc.compute(trades)
assert m.total_trades == 4
assert m.win_rate == Decimal('0.7500')  # 3/4
assert float(m.profit_factor) > 1  # profitable
assert isinstance(m.sharpe_ratio, Decimal)
assert isinstance(m.max_drawdown, Decimal)
assert isinstance(m.expectancy, Decimal)
print('MetricsCalculator: PASSED')
print('ALL CHECKS PASSED')
"
```
  </verify>
  <done>SessionSpreadModel returns correct spread for all 4 sessions and off-session. MetricsCalculator computes all 5 metrics with correct edge case handling, all outputs are Decimal.</done>
</task>

</tasks>

<verification>
1. All three service files exist and import cleanly: `python -c "from app.services.trade_simulator import *; from app.services.spread_model import *; from app.services.metrics_calculator import *"`
2. TradeSimulator correctly handles BUY trades (spread adjusts entry up), SELL trades (spread checks on SL exit), SL priority, and EXPIRED outcome
3. SessionSpreadModel uses existing session_filter.get_active_sessions() -- no duplicated session logic
4. MetricsCalculator handles empty, single, all-win, and all-loss trade lists without errors
5. All Decimal outputs are compatible with BacktestResult Numeric(10,4) columns
</verification>

<success_criteria>
- TradeSimulator.simulate_trade() correctly determines SL_HIT, TP1_HIT, TP2_HIT, EXPIRED outcomes for both BUY and SELL directions
- SL always takes priority when both SL and TP could hit in the same bar
- SpreadModel returns Decimal("0.20") during overlap, Decimal("0.30") during London/NY, Decimal("0.50") during Asian/off-session
- MetricsCalculator.compute() returns all 5 required metrics as Decimal values with 4 decimal places
- No vectorbt dependency -- all computation is manual pandas/numpy
</success_criteria>

<output>
After completion, create `.planning/phases/03-backtesting-engine/03-01-SUMMARY.md`
</output>
