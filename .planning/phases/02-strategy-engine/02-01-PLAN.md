---
phase: 02-strategy-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - app/strategies/__init__.py
  - app/strategies/base.py
  - app/strategies/helpers/__init__.py
  - app/strategies/helpers/indicators.py
  - app/strategies/helpers/swing_detection.py
  - app/strategies/helpers/session_filter.py
  - app/strategies/helpers/market_structure.py
autonomous: true

must_haves:
  truths:
    - "BaseStrategy ABC exists with abstract analyze(), name, required_timeframes, min_candles"
    - "CandidateSignal Pydantic model validates signal outputs with Decimal price fields matching Signal DB model"
    - "BaseStrategy._registry auto-populates via __init_subclass__ when a concrete subclass is defined"
    - "InsufficientDataError is raised when candles < min_candles"
    - "Helper modules provide EMA, ATR, VWAP wrappers, swing detection, session filter, and market structure shift detection"
  artifacts:
    - path: "app/strategies/base.py"
      provides: "BaseStrategy ABC, CandidateSignal, Direction enum, InsufficientDataError, registry methods"
      exports: ["BaseStrategy", "CandidateSignal", "Direction", "InsufficientDataError"]
    - path: "app/strategies/__init__.py"
      provides: "Package init that re-exports base classes"
      exports: ["BaseStrategy", "CandidateSignal", "InsufficientDataError"]
    - path: "app/strategies/helpers/indicators.py"
      provides: "Thin wrappers around pandas-ta for EMA, ATR, VWAP, RSI"
      exports: ["compute_ema", "compute_atr", "compute_vwap", "compute_rsi"]
    - path: "app/strategies/helpers/swing_detection.py"
      provides: "Swing high/low detection using scipy argrelextrema"
      exports: ["detect_swing_highs", "detect_swing_lows"]
    - path: "app/strategies/helpers/session_filter.py"
      provides: "Session time windows and filtering functions"
      exports: ["get_active_sessions", "is_in_session", "SESSIONS"]
    - path: "app/strategies/helpers/market_structure.py"
      provides: "Break of structure (BOS) and change of character (CHoCH) detection"
      exports: ["detect_bos", "detect_choch", "detect_structure_shift"]
    - path: "requirements.txt"
      provides: "Updated dependencies with pandas-ta-classic, pandas, numpy, scipy"
      contains: "pandas-ta-classic"
  key_links:
    - from: "app/strategies/base.py"
      to: "app/strategies/__init__.py"
      via: "re-export imports"
      pattern: "from app.strategies.base import"
    - from: "app/strategies/base.py"
      to: "app/models/signal.py"
      via: "CandidateSignal field alignment"
      pattern: "entry_price.*Decimal|stop_loss.*Decimal|take_profit_1.*Decimal"
---

<objective>
Create the strategy engine foundation: BaseStrategy abstract base class with auto-registration via `__init_subclass__`, CandidateSignal Pydantic model aligned with the existing Signal DB model, InsufficientDataError, and a helpers module providing thin wrappers around pandas-ta indicators, scipy-based swing detection, forex session time filtering, and market structure shift detection.

Purpose: All three concrete strategies (Plans 02-02 and 02-03) depend on this shared interface and helper toolkit. Without this foundation, no strategy can be implemented.

Output: `app/strategies/` package with base classes and helpers; updated `requirements.txt` with pandas-ta-classic, pandas, numpy, scipy.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-strategy-engine/02-RESEARCH.md
@app/models/signal.py
@app/models/candle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: BaseStrategy ABC, CandidateSignal model, registry, and dependencies</name>
  <files>
    requirements.txt
    app/strategies/__init__.py
    app/strategies/base.py
  </files>
  <action>
    **1. Update requirements.txt** -- append these four dependencies:
    ```
    pandas-ta-classic>=0.3.59
    pandas>=2.0
    numpy>=1.26
    scipy>=1.12
    ```
    Then run `pip install -r requirements.txt` to install them.

    **2. Create `app/strategies/base.py`** with:

    - `Direction(str, Enum)` with BUY and SELL values.

    - `CandidateSignal(BaseModel)` Pydantic model with fields aligned to the existing Signal DB model (`app/models/signal.py`):
      - `strategy_name: str`
      - `symbol: str = "XAUUSD"`
      - `timeframe: str` (e.g. "M15", "H1", "H4", "D1")
      - `direction: Direction`
      - `entry_price: Decimal` (use `Field(max_digits=10, decimal_places=2)`)
      - `stop_loss: Decimal` (same precision)
      - `take_profit_1: Decimal` (same precision)
      - `take_profit_2: Decimal` (same precision)
      - `risk_reward: Decimal` (use `Field(max_digits=5, decimal_places=2)`)
      - `confidence: Decimal` (use `Field(ge=Decimal("0"), le=Decimal("100"), max_digits=5, decimal_places=2)`)
      - `reasoning: str`
      - `timestamp: datetime` (candle timestamp that triggered the signal)
      - `invalidation_price: Decimal | None = None`
      - `session: str | None = None` (e.g. "london", "new_york", "asian")

    - `InsufficientDataError(Exception)` for when candle count is below strategy minimum.

    - `BaseStrategy(ABC)` with:
      - Class-level `_registry: dict[str, type["BaseStrategy"]] = {}`
      - `__init_subclass__` that registers concrete subclasses (skip classes with `__abstractmethods__`) using `cls.name` as key
      - Abstract properties: `name -> str`, `required_timeframes -> list[str]`, `min_candles -> int`
      - Abstract method: `analyze(self, candles: pd.DataFrame) -> list[CandidateSignal]`
      - Concrete method: `validate_data(self, candles: pd.DataFrame) -> None` that raises `InsufficientDataError` if `len(candles) < self.min_candles`, and raises `ValueError` if required columns (`timestamp, open, high, low, close`) are missing
      - Class methods: `get_registry() -> dict[str, type["BaseStrategy"]]`, `get_strategy(name: str) -> "BaseStrategy"` (raises KeyError if not found)

    - Utility function `candles_to_dataframe(candles: list) -> pd.DataFrame` that converts Candle ORM objects to a float-based DataFrame for pandas-ta. Converts Decimal fields (open, high, low, close, volume) to float. Sorts by timestamp ascending. Resets index.

    **Important implementation notes:**
    - Use `name` as a class attribute (not `@property`) on concrete strategies. The `__init_subclass__` check should use `hasattr(cls, 'name') and isinstance(cls.name, str)` to only register classes that define a string `name`.
    - Do NOT use `@abstractmethod` on `name`, `required_timeframes`, `min_candles` -- use class attributes instead. This avoids the `@property @abstractmethod` complexity. Document that concrete strategies MUST define these as class attributes.
    - Keep `analyze()` as the only `@abstractmethod`.

    **3. Create `app/strategies/__init__.py`** that imports and re-exports `BaseStrategy`, `CandidateSignal`, `Direction`, `InsufficientDataError`, and `candles_to_dataframe` from `base.py`. Do NOT import concrete strategies yet (they don't exist). Add a comment: `# Concrete strategy imports will be added as strategies are implemented`.
  </action>
  <verify>
    Run: `python -c "from app.strategies.base import BaseStrategy, CandidateSignal, Direction, InsufficientDataError, candles_to_dataframe; print('Base imports OK'); print('Registry:', BaseStrategy.get_registry())"`
    Expected: Imports succeed, registry is empty dict.

    Run: `python -c "from app.strategies import BaseStrategy, CandidateSignal; print('Package imports OK')"`
    Expected: Imports succeed.

    Run: `python -c "
from decimal import Decimal
from datetime import datetime, timezone
from app.strategies.base import CandidateSignal, Direction
sig = CandidateSignal(
    strategy_name='test', timeframe='H1', direction=Direction.BUY,
    entry_price=Decimal('2650.00'), stop_loss=Decimal('2640.00'),
    take_profit_1=Decimal('2665.00'), take_profit_2=Decimal('2680.00'),
    risk_reward=Decimal('1.50'), confidence=Decimal('75.00'),
    reasoning='test signal', timestamp=datetime.now(timezone.utc)
)
print('CandidateSignal validation OK:', sig.strategy_name)
"`
    Expected: CandidateSignal validates and creates successfully.
  </verify>
  <done>
    BaseStrategy ABC exists with registry via __init_subclass__, CandidateSignal validates with Decimal fields matching Signal DB model, InsufficientDataError exists, candles_to_dataframe converts ORM objects to float DataFrame, all imports work from both base.py and package __init__.py, requirements.txt includes pandas-ta-classic/pandas/numpy/scipy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Strategy helper modules (indicators, swing detection, session filter, market structure)</name>
  <files>
    app/strategies/helpers/__init__.py
    app/strategies/helpers/indicators.py
    app/strategies/helpers/swing_detection.py
    app/strategies/helpers/session_filter.py
    app/strategies/helpers/market_structure.py
  </files>
  <action>
    **1. Create `app/strategies/helpers/__init__.py`** that re-exports key functions from all helper modules.

    **2. Create `app/strategies/helpers/indicators.py`** -- thin wrappers around pandas-ta:

    - `compute_ema(series: pd.Series, length: int) -> pd.Series` -- wraps `pandas_ta.ema()`. Returns the EMA series.
    - `compute_atr(high: pd.Series, low: pd.Series, close: pd.Series, length: int = 14) -> pd.Series` -- wraps `pandas_ta.atr()`.
    - `compute_vwap(df: pd.DataFrame) -> pd.Series` -- wraps `pandas_ta.vwap()`. **Important:** Requires DatetimeIndex. The function should set `df.index = pd.DatetimeIndex(df["timestamp"])` on a copy before calling `ta.vwap()`, then return the result aligned to the original index. If volume is all zero/NaN, return a Series of NaN with a logged warning.
    - `compute_rsi(series: pd.Series, length: int = 14) -> pd.Series` -- wraps `pandas_ta.rsi()`.

    Each wrapper should accept and return pandas Series/DataFrames, adding no extra logic beyond the pandas-ta call (plus the VWAP DatetimeIndex setup). Use `from loguru import logger` for any warnings.

    **3. Create `app/strategies/helpers/swing_detection.py`**:

    - `detect_swing_highs(highs: pd.Series, order: int = 5) -> np.ndarray` -- uses `scipy.signal.argrelextrema(highs.values, np.greater_equal, order=order)[0]`. Returns array of indices.
    - `detect_swing_lows(lows: pd.Series, order: int = 5) -> np.ndarray` -- uses `scipy.signal.argrelextrema(lows.values, np.less_equal, order=order)[0]`. Returns array of indices.

    **4. Create `app/strategies/helpers/session_filter.py`**:

    - `SESSIONS` dict with UTC hour ranges:
      - `"asian": (23, 8)` -- wraps midnight
      - `"london": (7, 16)`
      - `"new_york": (12, 21)`
      - `"overlap": (12, 16)`

    - `get_active_sessions(timestamp: datetime) -> list[str]` -- returns list of active session names for a given UTC timestamp. Handles midnight wrap for Asian session.
    - `is_in_session(timestamp: datetime, session: str) -> bool` -- checks if timestamp is in named session. Raises ValueError for unknown session name.

    **5. Create `app/strategies/helpers/market_structure.py`**:

    - `detect_structure_shift(candles: pd.DataFrame, swing_highs: np.ndarray, swing_lows: np.ndarray) -> list[dict]` -- detects Break of Structure (BOS) events. A bullish BOS occurs when price breaks above a previous swing high after a swing low. A bearish BOS when price breaks below a previous swing low after a swing high. Returns list of dicts with keys: `index`, `type` ("bullish_bos" or "bearish_bos"), `broken_level` (the price level that was broken).

    - `detect_choch(candles: pd.DataFrame, swing_highs: np.ndarray, swing_lows: np.ndarray) -> list[dict]` -- detects Change of Character. A bullish CHoCH = first higher high after a series of lower highs. A bearish CHoCH = first lower low after a series of higher lows. Returns list of dicts with keys: `index`, `type` ("bullish_choch" or "bearish_choch"), `level`.

    Keep market structure detection simple and robust. Avoid over-engineering -- these are helper functions that strategies will call. Each function should work on the full DataFrame without lookahead bias (only use data up to the current bar index).
  </action>
  <verify>
    Run: `python -c "
from app.strategies.helpers.indicators import compute_ema, compute_atr, compute_vwap, compute_rsi
from app.strategies.helpers.swing_detection import detect_swing_highs, detect_swing_lows
from app.strategies.helpers.session_filter import get_active_sessions, is_in_session, SESSIONS
from app.strategies.helpers.market_structure import detect_structure_shift, detect_choch
print('All helper imports OK')
print('Sessions:', SESSIONS)
"`
    Expected: All imports succeed, SESSIONS dict printed.

    Run: `python -c "
import pandas as pd
import numpy as np
from app.strategies.helpers.indicators import compute_ema, compute_atr
series = pd.Series([float(i) for i in range(100)])
ema = compute_ema(series, 20)
print('EMA length:', len(ema), 'Last EMA:', ema.iloc[-1])
"`
    Expected: EMA computes without error, returns Series of same length.

    Run: `python -c "
from datetime import datetime, timezone
from app.strategies.helpers.session_filter import get_active_sessions
# 10:00 UTC = London session
ts = datetime(2026, 2, 17, 10, 0, tzinfo=timezone.utc)
sessions = get_active_sessions(ts)
print('Active sessions at 10:00 UTC:', sessions)
assert 'london' in sessions
# 14:00 UTC = London + NY + overlap
ts2 = datetime(2026, 2, 17, 14, 0, tzinfo=timezone.utc)
sessions2 = get_active_sessions(ts2)
print('Active sessions at 14:00 UTC:', sessions2)
assert 'london' in sessions2 and 'new_york' in sessions2 and 'overlap' in sessions2
print('Session filter tests passed')
"`
    Expected: Correct sessions identified.
  </verify>
  <done>
    Four helper modules exist under app/strategies/helpers/ with: pandas-ta indicator wrappers (EMA, ATR, VWAP, RSI), scipy swing detection (highs and lows), UTC session filtering (Asian/London/NY/overlap), and market structure shift detection (BOS/CHoCH). All functions importable and functional on basic data.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.strategies.base import BaseStrategy; assert BaseStrategy.get_registry() == {}"` -- registry starts empty
2. `python -c "from app.strategies.base import CandidateSignal; print(CandidateSignal.model_fields.keys())"` -- all expected fields present
3. `python -c "from app.strategies.helpers import indicators, swing_detection, session_filter, market_structure"` -- all helpers importable
4. `pip list | grep -E 'pandas-ta|scipy|numpy|pandas'` -- all dependencies installed
</verification>

<success_criteria>
- BaseStrategy ABC with __init_subclass__ registry exists and can register/retrieve strategies
- CandidateSignal Pydantic model has all fields matching Signal DB model (entry_price, stop_loss, take_profit_1, take_profit_2, risk_reward, confidence, reasoning, direction, timeframe, symbol)
- InsufficientDataError is defined and raiseable
- candles_to_dataframe converts Decimal ORM fields to float DataFrame
- Helper modules all import and execute basic operations without error
- requirements.txt updated with pandas-ta-classic, pandas, numpy, scipy
</success_criteria>

<output>
After completion, create `.planning/phases/02-strategy-engine/02-01-SUMMARY.md`
</output>
