---
phase: 02-strategy-engine
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - app/strategies/trend_continuation.py
  - app/strategies/breakout_expansion.py
  - app/strategies/__init__.py
  - tests/test_trend_continuation.py
  - tests/test_breakout_expansion.py
  - tests/test_strategy_registry.py
autonomous: true

must_haves:
  truths:
    - "TrendContinuationStrategy.analyze() detects EMA-trend pullbacks and returns CandidateSignal(s) with entry, SL, TP, direction, and reasoning"
    - "BreakoutExpansionStrategy.analyze() detects consolidation breakouts and returns CandidateSignal(s) with entry, SL, TP, direction, and reasoning"
    - "All three strategies appear in BaseStrategy.get_registry() -- registry length is 3"
    - "Adding a hypothetical fourth strategy requires only one new file and one import line in __init__.py -- no changes to base classes or downstream code"
    - "Each strategy declares distinct required_timeframes and min_candles values"
  artifacts:
    - path: "app/strategies/trend_continuation.py"
      provides: "TrendContinuationStrategy concrete class"
      exports: ["TrendContinuationStrategy"]
    - path: "app/strategies/breakout_expansion.py"
      provides: "BreakoutExpansionStrategy concrete class"
      exports: ["BreakoutExpansionStrategy"]
    - path: "app/strategies/__init__.py"
      provides: "Complete package exports with all three strategies"
      contains: "BreakoutExpansionStrategy"
    - path: "tests/test_trend_continuation.py"
      provides: "Unit tests for trend continuation strategy"
      contains: "test_"
    - path: "tests/test_breakout_expansion.py"
      provides: "Unit tests for breakout expansion strategy"
      contains: "test_"
    - path: "tests/test_strategy_registry.py"
      provides: "Integration tests verifying all 3 strategies registered and new-strategy-zero-change pattern"
      contains: "test_registry"
  key_links:
    - from: "app/strategies/trend_continuation.py"
      to: "app/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class TrendContinuationStrategy\\(BaseStrategy\\)"
    - from: "app/strategies/breakout_expansion.py"
      to: "app/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class BreakoutExpansionStrategy\\(BaseStrategy\\)"
    - from: "app/strategies/__init__.py"
      to: "all strategy modules"
      via: "import triggers registration"
      pattern: "from app.strategies.trend_continuation|from app.strategies.breakout_expansion"
    - from: "tests/test_strategy_registry.py"
      to: "app/strategies/__init__.py"
      via: "registry verification"
      pattern: "BaseStrategy.get_registry"
---

<objective>
Implement the remaining two strategies -- Trend Continuation (STRAT-02) and Breakout Expansion (STRAT-03) -- and create a registry integration test that proves all three strategies are registered and that the zero-change extensibility pattern (STRAT-07) works.

Purpose: Completes the Phase 2 strategy engine with all three strategies operational and the registry pattern fully validated.

Output: Two working strategy classes with passing unit tests, plus a registry integration test confirming all three strategies and the extensibility guarantee.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-strategy-engine/02-RESEARCH.md
@.planning/phases/02-strategy-engine/02-01-SUMMARY.md
@.planning/phases/02-strategy-engine/02-02-SUMMARY.md
@app/strategies/base.py
@app/strategies/liquidity_sweep.py
@app/strategies/helpers/indicators.py
@app/strategies/helpers/swing_detection.py
@app/strategies/helpers/session_filter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TrendContinuationStrategy and BreakoutExpansionStrategy</name>
  <files>
    app/strategies/trend_continuation.py
    app/strategies/breakout_expansion.py
    app/strategies/__init__.py
  </files>
  <action>
    **1. Create `app/strategies/trend_continuation.py`** implementing STRAT-02: Trend Continuation.

    Class attributes:
    - `name = "trend_continuation"`
    - `required_timeframes = ["H1"]`
    - `min_candles = 200` (EMA-200 warmup)

    **`analyze(self, candles: pd.DataFrame) -> list[CandidateSignal]`** logic:

    1. Call `self.validate_data(candles)`.
    2. `candles = candles.copy()`.
    3. Compute indicators:
       - EMA-50 via `compute_ema(candles["close"], 50)`
       - EMA-200 via `compute_ema(candles["close"], 200)`
       - ATR-14 via `compute_atr(candles["high"], candles["low"], candles["close"], 14)`
       - Optionally VWAP via `compute_vwap(candles)` -- if VWAP returns all NaN (no volume), skip VWAP filter
    4. Scan from bar `min_candles` onward:
       - **Trend direction:** EMA-50 > EMA-200 = bullish, EMA-50 < EMA-200 = bearish. Skip bars where EMAs are within 0.5 * ATR of each other (no clear trend).
       - **Pullback detection (bullish):** Price was above EMA-50 in recent bars, then retraces to within 1 ATR of EMA-50 (i.e., `close <= ema_50 + atr` and `close >= ema_50 - atr`). The pullback low should be at or near EMA-50.
       - **Pullback detection (bearish):** Price was below EMA-50 in recent bars, then retraces up to within 1 ATR of EMA-50.
       - **Momentum confirmation:** After pullback, candle closes back in trend direction -- for bullish: close > open and close > previous candle's high. For bearish: close < open and close < previous candle's low.
    5. Session filter: London and New York sessions only (use `is_in_session()`).
    6. Signal fields:
       - **Entry:** Confirmation candle close
       - **Stop loss (BUY):** Below the pullback low minus 1.5 * ATR. Minimum SL distance = 1.5 * ATR.
       - **Stop loss (SELL):** Above the pullback high plus 1.5 * ATR.
       - **TP1:** 2:1 R:R from entry
       - **TP2:** Nearest swing high (BUY) or swing low (SELL) using `detect_swing_highs/lows`. If no valid swing target, use 3:1 R:R.
       - **Risk/reward:** TP1 distance / risk distance (should be ~2.0)
       - **Confidence:** Base 50. +10 if VWAP confirms trend (price above VWAP for bullish, below for bearish). +10 if pullback depth is shallow (< 0.5 * ATR from EMA-50). +10 if in overlap session. +10 if EMA-50/200 spread is widening (trend strengthening). Cap at 100.
       - **Reasoning:** e.g., "Bullish trend continuation: EMA-50 above EMA-200, pullback to EMA-50 zone, momentum confirmation candle."
    7. Convert all prices to Decimal via `Decimal(str(round(float_price, 2)))`.

    **2. Create `app/strategies/breakout_expansion.py`** implementing STRAT-03: Breakout Expansion.

    Class attributes:
    - `name = "breakout_expansion"`
    - `required_timeframes = ["H1"]`
    - `min_candles = 70` (ATR-50 + consolidation detection window)

    **`analyze(self, candles: pd.DataFrame) -> list[CandidateSignal]`** logic:

    1. Call `self.validate_data(candles)`.
    2. `candles = candles.copy()`.
    3. Compute indicators:
       - ATR-14 via `compute_atr()`
       - ATR rolling 50-bar average: `candles["atr"].rolling(window=50).mean()`
    4. Detect consolidation ranges:
       - Find periods where ATR < 0.5 * ATR_MA_50 for at least 10 consecutive bars
       - Record range_high (max high during consolidation) and range_low (min low during consolidation)
       - Only consider the most recent consolidation range (not old stale ranges)
    5. Detect breakout:
       - **Bullish breakout:** Candle closes above range_high
       - **Bearish breakout:** Candle closes below range_low
       - **Volume confirmation (optional):** If volume data exists and is non-zero, check that breakout bar volume > 1.5 * average volume over consolidation. If no volume data, skip this filter.
    6. Session filter: Any session is valid for breakouts (they can happen anytime), but add +10 confidence if during London open (07:00-09:00 UTC) as breakouts are more reliable then.
    7. Signal fields:
       - **Entry:** Breakout candle close
       - **Stop loss (BUY):** range_low (or midpoint of range if range is very wide, defined as > 3 * ATR)
       - **Stop loss (SELL):** range_high (or midpoint if range > 3 * ATR)
       - **TP1:** Entry + 1.0 * range_height (BUY) or Entry - 1.0 * range_height (SELL), where range_height = range_high - range_low
       - **TP2:** Entry + 2.0 * range_height (BUY) or Entry - 2.0 * range_height (SELL)
       - **Risk/reward:** TP1 distance / risk distance
       - **Confidence:** Base 50. +10 if consolidation lasted > 20 bars (stronger range). +10 if breakout candle body > 1.5 * ATR (strong momentum). +10 if volume confirms. +10 if London open session. Cap at 100.
       - **Reasoning:** e.g., "Bullish breakout from {duration}-bar consolidation range ({range_low}-{range_high}). ATR expansion confirms volatility breakout."
    8. Convert all prices to Decimal.

    **3. Update `app/strategies/__init__.py`** to add imports for both new strategies:
    ```python
    from app.strategies.trend_continuation import TrendContinuationStrategy
    from app.strategies.breakout_expansion import BreakoutExpansionStrategy
    ```
    Add both to `__all__`.
  </action>
  <verify>
    Run: `python -c "
from app.strategies import BaseStrategy
registry = BaseStrategy.get_registry()
print('Registry:', sorted(registry.keys()))
assert len(registry) == 3, f'Expected 3 strategies, got {len(registry)}'
assert 'liquidity_sweep' in registry
assert 'trend_continuation' in registry
assert 'breakout_expansion' in registry
print('All 3 strategies registered')
"`
    Expected: All three strategies registered.

    Run: `python -c "
from app.strategies import TrendContinuationStrategy, BreakoutExpansionStrategy
tc = TrendContinuationStrategy()
be = BreakoutExpansionStrategy()
print(f'TC: name={tc.name}, timeframes={tc.required_timeframes}, min_candles={tc.min_candles}')
print(f'BE: name={be.name}, timeframes={be.required_timeframes}, min_candles={be.min_candles}')
assert tc.min_candles == 200
assert be.min_candles == 70
print('Strategy attributes OK')
"`
    Expected: Both strategies instantiate with correct attributes.
  </verify>
  <done>
    TrendContinuationStrategy and BreakoutExpansionStrategy are implemented, auto-registered, and have distinct entry/SL/TP logic. The __init__.py imports all three strategies. Registry contains exactly 3 entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for both strategies + registry integration test</name>
  <files>
    tests/test_trend_continuation.py
    tests/test_breakout_expansion.py
    tests/test_strategy_registry.py
  </files>
  <action>
    **1. Create `tests/test_trend_continuation.py`** with synthetic candle data tests.

    Helper: `make_trending_candles(count=250, direction="up", base_price=2600.0)` -- generates candles with a clear trend (gradually rising for "up", falling for "down") during London session hours (10:00 UTC base). For uptrend: EMA-50 should be above EMA-200 after warmup. Include a pullback zone around bar 220-230 where price dips to EMA-50 then bounces.

    Test cases:
    1. `test_strategy_registered()` -- "trend_continuation" in registry
    2. `test_insufficient_data_raises()` -- 100 candles (< 200 min) raises InsufficientDataError
    3. `test_analyze_returns_list()` -- Returns a list (possibly empty)
    4. `test_signal_fields_valid()` -- If signals produced: direction in (BUY, SELL), prices are Decimal, entry > 0, risk_reward > 0, confidence 0-100
    5. `test_buy_signal_price_ordering()` -- BUY: SL < entry < TP1 < TP2
    6. `test_sell_signal_price_ordering()` -- SELL: TP2 < TP1 < entry < SL
    7. `test_strategy_name_correct()` -- All signals have strategy_name == "trend_continuation"
    8. `test_min_candles_200()` -- strategy.min_candles == 200
    9. `test_validate_data_missing_columns()` -- DataFrame missing "close" column raises ValueError

    **2. Create `tests/test_breakout_expansion.py`** with synthetic candle data tests.

    Helper: `make_consolidation_breakout_candles(count=120, base_price=2650.0)` -- generates candles where:
    - Bars 0-20: establish price range with normal ATR
    - Bars 20-80: tight consolidation (small candles, price stays in narrow range of ~$5)
    - Bar 85-90: breakout candle that closes decisively above the consolidation range high

    Test cases:
    1. `test_strategy_registered()` -- "breakout_expansion" in registry
    2. `test_insufficient_data_raises()` -- 30 candles (< 70 min) raises InsufficientDataError
    3. `test_analyze_returns_list()` -- Returns a list
    4. `test_signal_fields_valid()` -- Validates CandidateSignal field types and ranges
    5. `test_buy_signal_price_ordering()` -- BUY: SL < entry < TP1 < TP2
    6. `test_sell_signal_price_ordering()` -- SELL: TP2 < TP1 < entry < SL
    7. `test_strategy_name_correct()` -- strategy_name == "breakout_expansion"
    8. `test_min_candles_70()` -- strategy.min_candles == 70
    9. `test_validate_data_missing_columns()` -- Missing column raises ValueError

    **3. Create `tests/test_strategy_registry.py`** -- integration test proving all Phase 2 success criteria:

    Test cases:
    1. `test_registry_has_three_strategies()` -- `len(BaseStrategy.get_registry()) == 3`
    2. `test_registry_keys()` -- Keys are exactly {"liquidity_sweep", "trend_continuation", "breakout_expansion"}
    3. `test_get_strategy_returns_instance()` -- `BaseStrategy.get_strategy("trend_continuation")` returns a TrendContinuationStrategy instance
    4. `test_get_strategy_unknown_raises()` -- `BaseStrategy.get_strategy("nonexistent")` raises KeyError
    5. `test_all_strategies_have_required_attributes()` -- Loop through all registered strategies: each has name (str), required_timeframes (list), min_candles (int > 0), and analyze method is callable
    6. `test_all_strategies_have_distinct_names()` -- No duplicate names in registry
    7. `test_zero_change_extensibility()` -- Create an inline test strategy class that subclasses BaseStrategy with name="test_dummy", verify it auto-registers, then clean up by removing it from _registry. This proves STRAT-07: adding a new strategy = one class definition.
    8. `test_each_strategy_declares_min_candles()` -- Every strategy's min_candles is > 0
    9. `test_each_strategy_declares_timeframes()` -- Every strategy's required_timeframes is a non-empty list

    Run all tests: `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_trend_continuation.py tests/test_breakout_expansion.py tests/test_strategy_registry.py -v`
  </action>
  <verify>
    Run: `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_trend_continuation.py tests/test_breakout_expansion.py tests/test_strategy_registry.py -v`
    Expected: All tests pass.

    Run: `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/ -v --ignore=tests/test_candle_ingestor.py --ignore=tests/test_api.py -k "not test_db"` (run all non-DB tests)
    Expected: All strategy tests pass (DB tests may be skipped/ignored if no test DB available).
  </verify>
  <done>
    Unit tests for TrendContinuationStrategy and BreakoutExpansionStrategy pass, covering registration, error handling, return types, field validation, and price ordering. Registry integration test confirms all 3 strategies registered, distinct names, required attributes declared, and zero-change extensibility pattern works.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.strategies import BaseStrategy; r = BaseStrategy.get_registry(); assert len(r) == 3; print('Registry OK:', sorted(r.keys()))"` -- 3 strategies registered
2. `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_strategy_registry.py -v` -- all registry tests pass
3. `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_trend_continuation.py tests/test_breakout_expansion.py tests/test_liquidity_sweep.py -v` -- all strategy tests pass
4. Each strategy has distinct min_candles: liquidity_sweep=100, trend_continuation=200, breakout_expansion=70
</verification>

<success_criteria>
- All three strategies (liquidity_sweep, trend_continuation, breakout_expansion) exist and are registered
- Each strategy has unique name, required_timeframes, and min_candles
- analyze() returns list[CandidateSignal] for all three strategies
- Registry integration test proves zero-change extensibility (STRAT-07)
- All unit tests pass
- Phase 2 is complete: every phase success criterion is met
</success_criteria>

<output>
After completion, create `.planning/phases/02-strategy-engine/02-03-SUMMARY.md`
</output>
