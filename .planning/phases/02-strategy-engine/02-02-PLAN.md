---
phase: 02-strategy-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/strategies/liquidity_sweep.py
  - app/strategies/__init__.py
  - tests/test_liquidity_sweep.py
autonomous: true

must_haves:
  truths:
    - "LiquiditySweepStrategy.analyze() detects stop hunts below/above swing levels and returns CandidateSignal(s) with entry, SL, TP, direction, and reasoning"
    - "LiquiditySweepStrategy appears in BaseStrategy.get_registry() under key 'liquidity_sweep'"
    - "InsufficientDataError is raised when fewer than min_candles are provided"
    - "Strategy only generates signals during London and New York sessions"
    - "No lookahead bias -- signals use only data up to and including the signal bar"
  artifacts:
    - path: "app/strategies/liquidity_sweep.py"
      provides: "LiquiditySweepStrategy concrete class"
      exports: ["LiquiditySweepStrategy"]
    - path: "app/strategies/__init__.py"
      provides: "Updated package exports including LiquiditySweepStrategy"
      contains: "LiquiditySweepStrategy"
    - path: "tests/test_liquidity_sweep.py"
      provides: "Unit tests for liquidity sweep strategy"
      contains: "test_"
  key_links:
    - from: "app/strategies/liquidity_sweep.py"
      to: "app/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class LiquiditySweepStrategy\\(BaseStrategy\\)"
    - from: "app/strategies/liquidity_sweep.py"
      to: "app/strategies/helpers/"
      via: "uses swing_detection, session_filter, market_structure, indicators"
      pattern: "from app.strategies.helpers"
    - from: "app/strategies/__init__.py"
      to: "app/strategies/liquidity_sweep.py"
      via: "import triggers registration"
      pattern: "from app.strategies.liquidity_sweep import"
---

<objective>
Implement the Liquidity Sweep Reversal strategy (STRAT-01) -- the first concrete strategy. This strategy detects stop hunts below/above key swing levels, waits for market structure shift confirmation, and produces CandidateSignal outputs. Includes unit tests using synthetic candle data (no database needed).

Purpose: Validates the BaseStrategy interface with a real strategy implementation and proves the registry pattern works end-to-end.

Output: Working `LiquiditySweepStrategy` class registered in the strategy registry, with passing unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-strategy-engine/02-RESEARCH.md
@.planning/phases/02-strategy-engine/02-01-SUMMARY.md
@app/strategies/base.py
@app/strategies/helpers/swing_detection.py
@app/strategies/helpers/session_filter.py
@app/strategies/helpers/market_structure.py
@app/strategies/helpers/indicators.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LiquiditySweepStrategy</name>
  <files>
    app/strategies/liquidity_sweep.py
    app/strategies/__init__.py
  </files>
  <action>
    **Create `app/strategies/liquidity_sweep.py`** implementing STRAT-01: Liquidity Sweep Reversal.

    Class attributes:
    - `name = "liquidity_sweep"`
    - `required_timeframes = ["H1"]`
    - `min_candles = 100` (need enough history for swing detection with order=5-10)

    **`analyze(self, candles: pd.DataFrame) -> list[CandidateSignal]`** logic:

    1. Call `self.validate_data(candles)`.
    2. `candles = candles.copy()` -- never modify input DataFrame.
    3. Compute indicators using helpers:
       - ATR-14 via `compute_atr(candles["high"], candles["low"], candles["close"], length=14)`
    4. Detect swing highs and swing lows using `detect_swing_highs(candles["high"], order=5)` and `detect_swing_lows(candles["low"], order=5)`.
    5. Scan for liquidity sweeps (from bar index = max(min_candles, 20) onward to avoid warmup):
       - **Bullish sweep:** Current candle's low wicks below a recent swing low (within last 50 bars), but closes above that swing low level. This suggests a stop hunt / institutional accumulation.
       - **Bearish sweep:** Current candle's high wicks above a recent swing high (within last 50 bars), but closes below that swing high level.
    6. After detecting a sweep, confirm with market structure shift:
       - For bullish: Look for a bullish BOS or CHoCH in the next 1-3 bars after the sweep bar (use `detect_structure_shift` or simpler check: does any of the next 3 candles close above the most recent swing high before the sweep?).
       - For bearish: Look for a bearish structure shift.
       - **Simplification for v1:** Use a simpler confirmation -- after a bullish sweep, the next candle (or within next 3 candles) must close above the sweep candle's high (showing bullish momentum). For bearish, close below the sweep candle's low.
    7. Session filter: Only generate signals where the sweep candle's timestamp is during London (07:00-16:00 UTC) or New York (12:00-21:00 UTC) sessions. Use `is_in_session()`.
    8. Calculate signal fields:
       - **Direction:** BUY for bullish sweep, SELL for bearish sweep
       - **Entry price:** The close of the confirmation candle (the candle that confirms the structure shift), converted to Decimal via `Decimal(str(round(price, 2)))`
       - **Stop loss:** For BUY: below the sweep wick low minus 0.5 * ATR. For SELL: above the sweep wick high plus 0.5 * ATR.
       - **Take profit 1:** Entry + 1.5 * risk_distance (BUY) or Entry - 1.5 * risk_distance (SELL), where risk_distance = |entry - stop_loss|
       - **Take profit 2:** Entry + 3.0 * risk_distance (BUY) or Entry - 3.0 * risk_distance (SELL)
       - **Risk/reward:** TP1 distance / risk_distance (should be ~1.5)
       - **Confidence:** Additive scoring (base 50): +10 if sweep wick is > 1 ATR beyond the swing level, +10 if confirmation candle is strong (close near high for BUY, near low for SELL), +10 if in overlap session (12:00-16:00 UTC), +10 if sweep was below multiple swing lows (stronger liquidity pool). Cap at 100.
       - **Reasoning:** Brief explanation like "Bullish liquidity sweep below swing low at {level}, confirmed by structure shift. Entry at {entry}, SL below sweep wick at {sl}."
       - **Timestamp:** The confirmation candle's timestamp
       - **Session:** Current active session name

    **Update `app/strategies/__init__.py`** to add:
    ```python
    from app.strategies.liquidity_sweep import LiquiditySweepStrategy
    ```
    And add `"LiquiditySweepStrategy"` to `__all__`.

    **Implementation notes:**
    - All price calculations use float internally, convert to Decimal only when creating CandidateSignal.
    - Use `Decimal(str(round(float_price, 2)))` for every price field.
    - Do not look ahead: when checking bar `i`, only use data from indices `0..i`.
    - Skip the first `min_candles` bars for signal generation even within a valid dataset (indicator warmup).
    - ATR at bar `i` may be NaN for early bars -- skip those.
  </action>
  <verify>
    Run: `python -c "
from app.strategies.base import BaseStrategy
from app.strategies.liquidity_sweep import LiquiditySweepStrategy
# Verify registration
registry = BaseStrategy.get_registry()
print('Registry:', list(registry.keys()))
assert 'liquidity_sweep' in registry, 'Strategy not registered'
# Verify attributes
s = LiquiditySweepStrategy()
print('Name:', s.name)
print('Timeframes:', s.required_timeframes)
print('Min candles:', s.min_candles)
assert s.name == 'liquidity_sweep'
assert s.min_candles == 100
print('LiquiditySweepStrategy OK')
"`
    Expected: Strategy registered and attributes correct.
  </verify>
  <done>
    LiquiditySweepStrategy is implemented, auto-registered in BaseStrategy._registry, produces CandidateSignal outputs with correct entry/SL/TP calculations, filters by London/NY sessions, and uses no lookahead.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for Liquidity Sweep strategy</name>
  <files>
    tests/test_liquidity_sweep.py
  </files>
  <action>
    **Create `tests/test_liquidity_sweep.py`** with synthetic candle data tests. These are pure function tests -- no database needed.

    Create a helper function `make_candles(count, base_price=2650.0, trend="flat")` that generates a DataFrame with columns [timestamp, open, high, low, close, volume]. Use `datetime(2026, 1, 1, 10, 0, tzinfo=timezone.utc)` as base (10:00 UTC = London session) with 1-hour increments. For `trend="flat"`, oscillate price gently. For `trend="up"`, add a gradual uptrend. For `trend="down"`, gradual downtrend.

    Create a helper `make_sweep_candles(count=150)` that generates a specific scenario:
    - First 80 candles: gentle uptrend establishing swing lows
    - Then a clear swing low forms around bar 80
    - Around bar 90-95: a candle that wicks below the swing low but closes above it (the liquidity sweep)
    - Bar 96-98: confirmation candle(s) that close above the sweep candle's high
    - Timestamps set during London session (10:00 UTC onward)

    **Test cases:**

    1. `test_strategy_registered()` -- BaseStrategy.get_registry() contains "liquidity_sweep"
    2. `test_insufficient_data_raises()` -- Passing 50 candles raises InsufficientDataError
    3. `test_analyze_returns_list_of_candidate_signals()` -- analyze() returns a list, every element is CandidateSignal
    4. `test_signal_fields_populated()` -- When a signal is produced, all required fields have valid values: direction in (BUY, SELL), entry_price > 0, stop_loss > 0, risk_reward > 0, confidence between 0-100, reasoning is non-empty
    5. `test_buy_signal_sl_below_entry()` -- For BUY signals: stop_loss < entry_price < take_profit_1 < take_profit_2
    6. `test_sell_signal_sl_above_entry()` -- For SELL signals: take_profit_2 < take_profit_1 < entry_price < stop_loss
    7. `test_no_signals_on_flat_data()` -- Flat, non-volatile data should produce few or no signals (not guaranteed zero, but validates no false positives from noise)
    8. `test_session_filter_applied()` -- All returned signals have timestamps within London or NY session hours
    9. `test_strategy_name_in_signals()` -- All signals have strategy_name == "liquidity_sweep"
    10. `test_validate_data_checks_columns()` -- Missing required column raises ValueError

    Use `pytest` conventions. No database fixtures needed. If `make_sweep_candles()` does not reliably produce signals (because the detection logic may need tuning), at minimum test that analyze() runs without error and returns a list. The key tests are: registration, error handling, field validation structure.

    Run tests with: `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_liquidity_sweep.py -v`
  </action>
  <verify>
    Run: `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_liquidity_sweep.py -v`
    Expected: All tests pass. At minimum: registration, insufficient data, column validation, return type, and strategy name tests must pass.
  </verify>
  <done>
    Unit tests for LiquiditySweepStrategy pass, covering: registry presence, insufficient data error, return type validation, signal field correctness (price ordering, confidence bounds, reasoning populated), session filtering, and strategy name consistency.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.strategies import LiquiditySweepStrategy; print('Import OK')"` -- strategy importable from package
2. `python -c "from app.strategies.base import BaseStrategy; assert 'liquidity_sweep' in BaseStrategy.get_registry()"` -- registered
3. `cd /Users/vaughanfawcett/TradingView && PYTHONPATH=. python -m pytest tests/test_liquidity_sweep.py -v` -- all tests pass
</verification>

<success_criteria>
- LiquiditySweepStrategy class exists, inherits BaseStrategy, and auto-registers as "liquidity_sweep"
- analyze() accepts a candle DataFrame and returns list[CandidateSignal]
- Signal prices use Decimal with 2 decimal places matching Signal DB model
- Session filter restricts signals to London/NY sessions
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-strategy-engine/02-02-SUMMARY.md`
</output>
