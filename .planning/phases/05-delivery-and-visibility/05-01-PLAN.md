---
phase: 05-delivery-and-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/config.py
  - app/services/telegram_notifier.py
  - app/workers/jobs.py
autonomous: true
user_setup:
  - service: telegram
    why: "Send trade signal alerts and outcome notifications"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram @BotFather -> /newbot -> copy token"
      - name: TELEGRAM_CHAT_ID
        source: "Send a message to your bot, then GET https://api.telegram.org/bot<TOKEN>/getUpdates -> result.message.chat.id"

must_haves:
  truths:
    - "TelegramNotifier.format_signal() produces HTML-formatted message with entry, SL, TP1, TP2, R:R, confidence, strategy, reasoning"
    - "TelegramNotifier.format_outcome() produces HTML-formatted message with result type, entry, exit price, P&L pips, duration (method built and tested, wired in Phase 6 when outcome detection exists)"
    - "Message delivery retries 3 times with exponential backoff on HTTP errors"
    - "Rate limiter enforces max 1 message per second to same chat"
    - "Signal pipeline calls notify_signal() after persisting signals without blocking on failure"
    - "System starts and works normally when TELEGRAM_BOT_TOKEN is empty (disabled mode)"
  artifacts:
    - path: "app/services/telegram_notifier.py"
      provides: "TelegramNotifier class with format_signal, format_outcome, notify_signal, notify_outcome"
      exports: ["TelegramNotifier"]
    - path: "app/config.py"
      provides: "telegram_bot_token and telegram_chat_id optional settings"
      contains: "telegram_bot_token"
  key_links:
    - from: "app/workers/jobs.py"
      to: "app/services/telegram_notifier.py"
      via: "run_signal_scanner creates TelegramNotifier and calls notify_signal after pipeline.run()"
      pattern: "notify_signal"
    - from: "app/services/telegram_notifier.py"
      to: "https://api.telegram.org"
      via: "httpx POST to sendMessage endpoint"
      pattern: "api.telegram.org"
---

<objective>
Build the Telegram notification service that sends formatted HTML trade signal alerts and outcome notifications via the Telegram Bot API, with retry logic and rate limiting, and wire it into the signal pipeline.

Purpose: This is the primary delivery channel for trade signals -- the trader receives instant alerts on their phone when a new signal fires or an outcome is detected, so they never miss a setup.

Output: A working TelegramNotifier class integrated into the signal pipeline that sends formatted messages on each new signal. The `notify_outcome()` method is built and tested but NOT wired in Phase 5 -- Phase 6 builds the outcome detection mechanism (TP1/TP2/SL hit checker job) that will call `notify_outcome()`. There is nothing to wire it into until that detector exists.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-and-visibility/05-RESEARCH.md

# Key existing files
@app/config.py
@app/services/signal_pipeline.py
@app/workers/jobs.py
@app/models/signal.py
@app/models/outcome.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TelegramNotifier service with signal/outcome formatting, retry, and rate limiting</name>
  <files>
    app/services/telegram_notifier.py
    app/config.py
  </files>
  <action>
    1. Add two optional settings to `app/config.py` Settings class:
       - `telegram_bot_token: str = ""` -- empty string default means disabled
       - `telegram_chat_id: str = ""` -- empty string default means disabled

    2. Create `app/services/telegram_notifier.py` with class `TelegramNotifier`:

       **Constructor:**
       - `__init__(self, bot_token: str, chat_id: str)` -- stores token, chat_id, creates `asyncio.Lock` for rate limiting, tracks `_last_send: float = 0.0`

       **Rate limiter:**
       - `async _rate_limit(self)` -- acquires asyncio.Lock, computes elapsed time since _last_send, sleeps if < 1.0 second to enforce TELE-05 max 1 msg/sec. Use `asyncio.get_event_loop().time()` for monotonic timing.

       **Message delivery with retry:**
       - `async _send_message(self, text: str) -> dict` -- decorated with `@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10), retry=retry_if_exception_type((httpx.HTTPStatusError, httpx.ConnectError)))`. Calls `_rate_limit()` first, then POSTs to `https://api.telegram.org/bot{token}/sendMessage` with JSON body `{"chat_id": chat_id, "text": text, "parse_mode": "HTML"}` using `httpx.AsyncClient(timeout=10.0)`. Calls `response.raise_for_status()`.

       **Signal formatting (TELE-01, TELE-03):**
       - `format_signal(self, signal: Signal) -> str` -- accepts Signal ORM object. Returns HTML string with:
         - Direction arrow (up arrow for BUY, down arrow for SELL) + bold "XAUUSD {direction}"
         - Entry, Stop Loss, TP1, TP2 as bold labels with values
         - R:R ratio and Confidence percentage
         - Strategy name (derive from strategy_id by accepting strategy_name as param or querying -- simplest: accept strategy_name as a separate parameter)
         - Reasoning in italics
         - Use HTML tags: `<b>`, `<i>` only (these are safe in Telegram HTML mode)

       **Actually, simplify format_signal signature:** Accept keyword arguments for the fields that aren't on the Signal model directly (like strategy_name):
       `format_signal(self, signal: Signal, strategy_name: str = "Unknown") -> str`

       **Outcome formatting (TELE-02, TELE-03):**
       - `format_outcome(self, signal: Signal, outcome: Outcome) -> str` -- accepts Signal and Outcome ORM objects. Returns HTML string with:
         - Emoji for result type: check mark for tp1_hit, double check for tp2_hit, X for sl_hit, clock for expired
         - Bold "XAUUSD {direction} - {result.upper()}"
         - Entry price, exit price, P&L pips, duration minutes

       **Fire-and-forget wrappers:**
       - `async notify_signal(self, signal: Signal, strategy_name: str = "Unknown") -> None` -- wraps format_signal + _send_message in try/except. Logs success with signal.id, logs exception on failure. Never raises.
       - `async notify_outcome(self, signal: Signal, outcome: Outcome) -> None` -- wraps format_outcome + _send_message in try/except. Logs success/failure. Never raises.

       **Disabled mode helper:**
       - `@property enabled(self) -> bool` -- returns `bool(self.bot_token and self.chat_id)`. All notify_* methods should check `self.enabled` first and return immediately with a debug log if disabled.
  </action>
  <verify>
    Run: `python -c "from app.services.telegram_notifier import TelegramNotifier; print('OK')"` succeeds.
    Run: `python -c "from app.config import Settings; s = Settings(_env_file=''); print(s.telegram_bot_token)"` prints empty string (no crash).
  </verify>
  <done>
    TelegramNotifier class exists with format_signal, format_outcome, notify_signal, notify_outcome methods. Config has optional telegram_bot_token and telegram_chat_id. Rate limiting and retry decorators are in place. Disabled mode returns early without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire TelegramNotifier into signal pipeline via jobs.py</name>
  <files>
    app/workers/jobs.py
  </files>
  <action>
    Modify `run_signal_scanner()` in `app/workers/jobs.py` to send Telegram notifications after the pipeline generates signals:

    1. After `signals = await pipeline.run(session)`, add notification logic:
       ```python
       # Send Telegram notifications for new signals (fire-and-forget)
       if signals:
           settings = get_settings()
           from app.services.telegram_notifier import TelegramNotifier
           from app.models.strategy import Strategy as StrategyModel
           notifier = TelegramNotifier(
               bot_token=settings.telegram_bot_token,
               chat_id=settings.telegram_chat_id,
           )
           if notifier.enabled:
               # Look up strategy names via session.get() (cached per strategy_id)
               strat_lookup = {}
               for sig in signals:
                   if sig.strategy_id not in strat_lookup:
                       strat_row = await session.get(StrategyModel, sig.strategy_id)
                       strat_lookup[sig.strategy_id] = strat_row.name if strat_row else "Unknown"
                   await notifier.notify_signal(sig, strategy_name=strat_lookup[sig.strategy_id])
       ```

    2. The notification block must be INSIDE the try/except already wrapping run_signal_scanner, so any notification errors are caught by the existing handler. But also, notify_signal itself never raises. This is double-safety.

    3. Do NOT modify signal_pipeline.py -- keep the notifier wiring in jobs.py (the job handler layer), not the pipeline itself. This keeps the pipeline pure (DB operations only) and notifications as a post-persist side effect.
  </action>
  <verify>
    Run: `python -c "from app.workers.jobs import run_signal_scanner; print('OK')"` succeeds (import check).
    Grep app/workers/jobs.py for "notify_signal" -- should find the call.
    Grep app/workers/jobs.py for "TelegramNotifier" -- should find the import.
  </verify>
  <done>
    run_signal_scanner() creates TelegramNotifier from settings, checks if enabled, and calls notify_signal() for each persisted signal after pipeline.run() completes. Notification failures are logged but never crash the scanner job.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.services.telegram_notifier import TelegramNotifier; t = TelegramNotifier('', ''); print(t.enabled)"` prints `False`
2. `python -c "from app.services.telegram_notifier import TelegramNotifier; t = TelegramNotifier('tok', '123'); print(t.enabled)"` prints `True`
3. `grep -c 'telegram_bot_token' app/config.py` returns 1+
4. `grep -c 'notify_signal' app/workers/jobs.py` returns 1+
5. All existing tests still pass: `PYTHONPATH=. python -m pytest tests/ -x -q`
</verification>

<success_criteria>
- TelegramNotifier class is importable and functional with format_signal, format_outcome, notify_signal, notify_outcome
- Config has optional telegram fields that default to empty string (disabled)
- Signal scanner job wires notifier after pipeline.run() with fire-and-forget semantics
- Rate limiting (1 msg/sec) and retry (3 attempts, exponential backoff) are implemented
- HTML parse mode used throughout (no MarkdownV2)
- System works normally when Telegram is not configured (empty token/chat_id)
- NOTE: `notify_outcome()` is built, tested, and importable but NOT wired into any job in Phase 5. Phase 6 builds the outcome detection mechanism (TP1/TP2/SL hit checker) that will call `notify_outcome()`. The method is ready; the caller does not exist yet.
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-and-visibility/05-01-SUMMARY.md`
</output>
